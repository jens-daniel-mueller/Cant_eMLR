---
title: "Mapping"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r library, message=FALSE, warning=FALSE}
library(tidyverse)
library(metR)
# library(lubridate)
# library(oce)
# library(marelac)
# library(reticulate)

```

```{r read_parameters, include = FALSE}

parameters <-
  read_rds(here::here("data",
                       "parameters.rds"))
```

```{r read_mask_files}

basinmask <- read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                                 "basin_mask_WOA18.csv"))

landmask <- read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                                 "land_mask_WOA18.csv"))

```

```{r read_parameters_functions, include = FALSE}
source(here::here("code", "plotting_functions.R"))
```

```{r ggplot_theme, include = FALSE}
theme_set(theme_bw())
```

# Predictor fields

Currently, we use combined predictor fields:

- WOA18: S, T, and derived variables
- GLODAP16: Oxygen, PO4, NO3, Silicate, and derived variables

```{r read_predictor_file}

predictors <- 
    read_csv(here::here("data/mapping/predictor_fields",
                         "W18_st_G16_opsn.csv"))

```

# Select phosphate star

Currently, mapping of Cant is based on PO4* calculated with:  
- `r parameters$phosphate_star_approach`

```{r select_phosphate_star_aproach}

if (parameters$phosphate_star_approach == "nitrate") {
  predictors <- predictors %>%
    mutate(phosphate_star = phosphate_star_nit) %>%
    select(-c(phosphate_star_oxy, phosphate_star_nit))
} else{
  predictors <- predictors %>%
    mutate(phosphate_star = phosphate_star_oxy) %>%
    select(-c(phosphate_star_oxy, phosphate_star_nit))
}
```


# Spatial boundaries

Only predictors were taken into consideration with:

- minimum sampling depth:  `r parameters$depth_min`m
- minimum bottom depth:  `r parameters$bottomdepth_min`m
- maximum latitude:  `r parameters$lat_max`°N


```{r apply_spatial_boundaries}

predictors <- predictors %>% 
  filter(depth >= parameters$depth_min)

predictors <- predictors %>% 
  filter(lat <= parameters$lat_max)

predictors_grid <- predictors %>% 
  group_by(lat, lon) %>% 
  summarise(bottomdepth = max(depth)) %>% 
  ungroup()

predictors <- full_join(predictors, predictors_grid)

predictors <- predictors %>% 
  filter(bottomdepth >= parameters$bottomdepth_min) %>% 
  select(-bottomdepth)

predictors <- predictors %>% drop_na()

```

# eMLRs

```{r load_eMLR_models}

all_lm_wide <-
  read_csv(here::here("data/eMLR",
                       "all_lm_wide.csv"))

```

# Merge MLRs + climatology

```{r merge_model_coeff_predictor_climatology}

all_lm_wide <- all_lm_wide %>% 
  mutate(model = str_remove(model, "Cstar ~ "))
         
Cant <- full_join(predictors, all_lm_wide)
#rm(predictors, all_lm_wide)

```

# Map Cant

## Apply MLRs to predictor

```{r calculate_Cant}

Cant <- Cant %>% 
  mutate(Cant = `delta_coeff_(Intercept)` +
           delta_coeff_aou * aou +
           delta_coeff_oxygen * oxygen +
           delta_coeff_phosphate * phosphate +
           delta_coeff_phosphate_star * phosphate_star +
           delta_coeff_silicate * silicate +
           delta_coeff_sal * sal + 
           delta_coeff_tem * tem)

```

## Mean Cant fields

Mean and sd are calculated for Cant in each grid cell (XYZ), basin and era combination. Calculations are performed for all Cant values vs positive values only. This averaging step summarizes the information derived from ten best fitting MLRs. 

```{r Calculate_Cant_mean}

Cant <- Cant %>%
  select(lon, lat, depth, eras, basin, Cant, gamma, model)

# Cant_model_average <- Cant %>%
#   mutate(Cant_pos = if_else(Cant < 0, 0, Cant)) %>%
#   group_by(lon, lat, depth, eras, basin) %>%
#   summarise(across(c("Cant", "Cant_pos", "gamma"),
#                    list(
#                      mean = ~ mean(.x, na.rm = TRUE),
#                      sd = ~ sd(.x, na.rm = TRUE)
#                    ))) %>%
#   ungroup()

Cant_model_average <- Cant %>%
  mutate(Cant_pos = if_else(Cant < 0, 0, Cant)) %>%
  group_by(lon, lat, depth, eras, basin) %>%
  summarise(Cant_mean = mean(Cant, na.rm = TRUE),
            Cant_sd = sd(Cant, na.rm = TRUE),
            Cant_pos_mean = mean(Cant_pos, na.rm = TRUE),
            Cant_pos_sd = sd(Cant_pos, na.rm = TRUE),
            gamma_mean = mean(gamma, na.rm = TRUE),
            gamma_sd = sd(gamma, na.rm = TRUE)) %>%
  ungroup()

Cant_model_average_Atl <- Cant_model_average %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Atl))

Cant_model_average_Ind_Pac <- Cant_model_average %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Ind_Pac))

Cant_model_average <- bind_rows(Cant_model_average_Atl, Cant_model_average_Ind_Pac)

rm(Cant_model_average_Atl, Cant_model_average_Ind_Pac)

```

## Mean Cant sections

For each basin and era combination, the zonal mean Cant is calculated, again for all vs positive only values. Likewise, sd is calculated for the averaging of the mean basin fields.

```{r Calculate_Cant_mean_sections}

Cant_model_average_zonal <- Cant_model_average %>%
  group_by(lat, depth, eras, basin) %>%
  summarise(across(
    c(
      "Cant_mean",
      "Cant_pos_mean",
      "Cant_sd",
      "Cant_pos_sd",
      "gamma_mean",
      "gamma_sd"
    ),
    list(mean = ~ mean(.x, na.rm = TRUE),
         sd = ~ sd(.x, na.rm = TRUE))
  )) %>%
  ungroup()


# Cant_model_average_zonal <- Cant_model_average %>% 
#   group_by(lat, depth, eras, basin) %>% 
#   summarise(Cant_mean_sd = sd(Cant_mean, na.rm = TRUE),
#             Cant_mean = mean(Cant_mean, na.rm = TRUE),
#             Cant_sd_mean = mean(Cant_sd, na.rm = TRUE),
#             Cant_pos_mean_sd = sd(Cant_pos_mean, na.rm = TRUE),
#             Cant_pos_mean = mean(Cant_pos_mean, na.rm = TRUE),
#             Cant_pos_sd_mean = mean(Cant_pos_sd, na.rm = TRUE),
#             gamma_mean = mean(gamma_mean)) %>% 
#   ungroup()


Cant_model_average_zonal_Atl <- Cant_model_average_zonal %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma_mean_mean, parameters$slabs_Atl))

Cant_model_average_zonal_Ind_Pac <- Cant_model_average_zonal %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma_mean_mean, parameters$slabs_Ind_Pac))

Cant_model_average_zonal <- bind_rows(Cant_model_average_zonal_Atl, Cant_model_average_zonal_Ind_Pac)

rm(Cant_model_average_zonal_Atl, Cant_model_average_zonal_Ind_Pac)

```


# Neutral density section

## Mean values

The mean zonal distribution of neutral densities was calculated. **CAVEAT:** Binning here does not include two highest isoneutral density slabs in the Atlantic, yet.

```{r gamma_sections_mean}

slab_breaks <- c(parameters$slabs_Atl[1:12],Inf)

Cant_model_average_zonal %>% 
  filter(depth <= parameters$inventory_depth) %>% 
  ggplot(aes(lat, depth, z = gamma_mean_mean)) +
  geom_contour_filled(breaks = slab_breaks) +
  geom_contour(breaks = slab_breaks,
               col = "white") +
  geom_text_contour(breaks = slab_breaks,
               col = "white",
               skip = 1) +
  scale_fill_viridis_d(name = "Gamma",
                       direction = -1) +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```

# Cant sections

## By model

```{r Cant_section_by_model_eras_lon, eval=FALSE}

for (i_eras in unique(Cant$eras)) {
  #i_eras <- unique(Cant$eras)[2]
  Cant_eras <- Cant %>%
    filter(eras == i_eras)
  
  for (i_lon in seq(20.5, 360, 20)) {
    #i_lon <- seq(20.5, 360, 20)[7]
    Cant_eras_lon <- Cant_eras %>%
      filter(lon == i_lon)
    
    Cant_eras_lon %>%
      ggplot(aes(lat, depth, fill = Cant)) +
      geom_raster() +
      scale_color_viridis_c() +
      scale_fill_divergent(
        guide = "colorstrip",
        breaks = MakeBreaks(5),
        name = "Cant",
        mid = "grey"
      ) +
      scale_y_reverse() +
      coord_cartesian(expand = 0) +
      guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
      labs(title = paste("eras:", i_eras, "| lon:", i_lon)) +
      facet_wrap(~ model, ncol = 5)
    
    ggsave(here::here("output/figure/mapping",
                  paste(i_eras,
                        "lon",
                        i_lon,
                        "model_Cant.png",
                        sep = "_")),
                  width = 17, height = 9)
    
  }
}


```


## Mean values

```{r Cant_sections_mean}

Cant_model_average_zonal %>%
  filter(depth <= parameters$inventory_depth) %>%
  ggplot(aes(lat, depth, z = Cant_mean_mean)) +
  geom_contour_fill(breaks = MakeBreaks(5),
                    na.fill = TRUE) +
  scale_fill_divergent(guide = "colorstrip",
                       breaks = MakeBreaks(5),
                       name = "Cant") +
  geom_contour(aes(lat, depth, z = gamma_mean_mean),
               breaks = slab_breaks,
               col = "black") +
  geom_text_contour(
    aes(lat, depth, z = gamma_mean_mean),
    breaks = slab_breaks,
    col = "black",
    skip = 1
  ) +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin ~ eras)

```

## Mean zonal standard deviation across MLR models

Standard deviation across Cant from all MLR models was calculate for each grid cell (XYZ). The zonal mean of this standard deviation should reflect the uncertainty associated to the predictor selection within each slab and era. 

```{r Cant_sections_sd_models}

Cant_model_average_zonal %>%
  filter(depth <= parameters$inventory_depth) %>%
  ggplot(aes(lat, depth, z = Cant_sd_mean)) +
  geom_contour_filled() +
  geom_contour(aes(lat, depth, z = gamma_mean_mean),
               breaks = slab_breaks,
               col = "white") +
  geom_text_contour(
    aes(lat, depth, z = gamma_mean_mean),
    breaks = slab_breaks,
    col = "white",
    skip = 1
  ) +
  scale_fill_viridis_d(name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin ~ eras)

```

## Zonal standard deviation of mean Cant estimates

Standard deviation of mean Cant values was calculate across all longitudes. This standard deviation should reflect the zonal variability of Cant within the basin and era.

```{r Cant_sections_sd_Cant}

Cant_model_average_zonal %>% 
  filter(depth <= parameters$inventory_depth) %>% 
  ggplot(aes(lat, depth, z = Cant_mean_sd)) +
  geom_contour_filled() +
  geom_contour(aes(lat, depth, z = gamma_mean_mean),
               breaks = slab_breaks,
               col = "white") +
  geom_text_contour(
    aes(lat, depth, z = gamma_mean_mean),
    breaks = slab_breaks,
    col = "white",
    skip = 1
  ) +
  scale_fill_viridis_d(name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```


## Mean positive values

```{r Cant_sections_positive_mean}

Cant_model_average_zonal %>% 
  filter(depth <= parameters$inventory_depth) %>% 
  ggplot(aes(lat, depth, z = Cant_pos_mean_mean)) +
  geom_contour_filled() +
  geom_contour(aes(lat, depth, z = gamma_mean_mean),
               breaks = slab_breaks,
               col = "white") +
  geom_text_contour(
    aes(lat, depth, z = gamma_mean_mean),
    breaks = slab_breaks,
    col = "white",
    skip = 1
  ) +
  scale_fill_viridis_d(name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```

## Sections

### JGOFS_GO

```{r Cant_sections_positive_mean_one_lon_JGOFS_GO}

section_climatology(Cant_model_average %>% filter(eras == "JGOFS_GO"),
                    "Cant_mean")

```

### GO_new

```{r Cant_sections_positive_mean_one_lon_GO_new}

section_climatology(Cant_model_average %>% filter(eras == "GO_new"),
                    "Cant_mean")

```


# Cant maps

## Depth layers

Cant concentration for selected depth levels at which mapping was performed.

```{r Cant_depth_layer_maps, fig.asp=1}

Cant_model_average %>%
  filter(depth %in% c(150, 500, 1000, 3000)) %>% 
  ggplot(aes(lon, lat, fill = Cant_mean)) + 
  geom_raster() +
  scale_fill_divergent(guide = "colorstrip",
                       breaks = MakeBreaks(5),
                       name = "Cant") +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  coord_quickmap(expand = 0) +
  facet_grid(depth~eras)

```

## Inventory calculation

To calculate Cant column inventories, we:  

1. Multiple layer thickness with Cant concentration to get a layer inventory
2. For each horizontal grid cell and era, sum Cant layer inventories from 150 - 3000 m

Step 2 is performed again for all Cant and positive Cant values only

```{r calculate_inventories}

depth_level_volume <- tibble(depth = unique(Cant_model_average$depth))

depth_level_volume <- depth_level_volume %>%
  mutate(
    layer_thickness_above = replace_na((depth - lag(depth)) / 2, 0),
    layer_thickness_below = replace_na((lead(depth) - depth) / 2, 0),
    layer_thickness = layer_thickness_above + layer_thickness_below
  ) %>%
  select(-c(layer_thickness_above,
            layer_thickness_below))

Cant_model_average <-
  full_join(Cant_model_average, depth_level_volume)

Cant_model_average <- Cant_model_average %>%
  mutate(layer_inv = Cant_mean * layer_thickness) %>%
  mutate(layer_inv_pos = if_else(layer_inv < 0, 0, layer_inv)) %>%
  select(-layer_thickness)

Cant_inv <- Cant_model_average %>%
  filter(depth <= parameters$inventory_depth) %>%
  group_by(lon, lat, basin, eras) %>%
  summarise(
    cant_inv_pos = sum(layer_inv_pos, na.rm = TRUE) / 1000,
    cant_inv     = sum(layer_inv, na.rm = TRUE) / 1000
  ) %>%
  ungroup()


```


## Inventories

### All Cant estimates

```{r Cant_inventory_map, fig.asp=1}

library(scales)

Cant_inv %>% 
  ggplot() +
    geom_raster(data = landmask %>% filter(region == "land"),
                aes(lon, lat), fill = "grey80") +
    geom_raster(aes(lon, lat, fill = cant_inv)) +
    coord_quickmap(expand = 0) +
    scale_fill_gradient2(high = muted("red"),
                         mid = "white",
                         low = muted("blue"),
                         midpoint = 0,
                         space = "Lab",
                         na.value = "green") +
  facet_wrap(~eras, ncol = 1) +
    theme(
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank()
    )

```


### Positive Cant estimates

```{r Cant_pos_inventory_map, fig.asp=1}

Cant_inv %>% 
  ggplot() +
    geom_raster(data = landmask %>% filter(region == "land"),
                aes(lon, lat), fill = "grey80") +
    geom_raster(aes(lon, lat, fill = cant_inv_pos)) +
    coord_quickmap(expand = 0) +
    scale_fill_viridis_c() +
  facet_wrap(~eras, ncol = 1) +
    theme(
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank()
    )

```

# Write csv

```{r write_cant_inventory}

Cant_model_average %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_2020.csv"))

Cant_inv %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_inv_2020.csv"))

```


# Open tasks

- Check PO4* calculation
- Harmonize AOU calculation in fitting and mapping
- Plot Cant sections for individual MLR models

# Open questions

- 
