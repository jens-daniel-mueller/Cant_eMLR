---
title: "Mapping Cant"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r library, message=FALSE, warning=FALSE}
library(tidyverse)
library(metR)
library(seacarb)
```

```{r read_parameters, include = FALSE}

parameters <-
  read_rds(here::here("data",
                       "parameters.rds"))
```

```{r read_mask_files}

basinmask <-
  read_csv(
    here::here(
      "data/World_Ocean_Atlas_2018/_summarized_files",
      "basin_mask_WOA18.csv"
    )
  )

basinmask_AIP <-
  read_csv(
    here::here(
      "data/World_Ocean_Atlas_2018/_summarized_files",
      "basin_mask_WOA18_AIP.csv"
    )
  )

landmask <-
  read_csv(
    here::here(
      "data/World_Ocean_Atlas_2018/_summarized_files",
      "land_mask_WOA18.csv"
    )
  )

section_global_coordinates <-
  read_csv(here::here("data",
                       "section_global_coordinates.csv"))
```

```{r read_parameters_functions, include = FALSE}
source(here::here("code", "plotting_functions.R"))
```

```{r ggplot_theme, include = FALSE}
theme_set(theme_bw())
```

# Predictor fields

Currently, we use combined predictor fields:

- WOA18: S, T, and derived variables
- GLODAP16: Oxygen, PO4, NO3, Silicate, and derived variables

```{r read_predictor_file}

predictors <- 
    read_csv(here::here("data/mapping/predictor_fields",
                         "W18_st_G16_opsn.csv"))

predictors_surface <- 
    read_csv(here::here("data/mapping/predictor_fields",
                         "W18_st_G16_opsn_surface.csv"))

```

# Atm. pCO2

```{r read_atm_pCO2}

co2_atm_tref <-
  read_csv(here::here(
    "data/pCO2_atmosphere/_summarized_data_files",
    "co2_atm_tref.csv"
  ))

```



# Load MLR models

```{r load_eMLR_models}

lm_all_wide <-
  read_csv(here::here("data/eMLR",
                       "lm_all_wide.csv"))
```

# Merge MLRs + climatologies

```{r merge_model_coeff_predictor_climatology}

lm_all_wide <- lm_all_wide %>% 
  mutate(model = str_remove(model, "Cstar ~ "))
         
Cant <- full_join(predictors, lm_all_wide)

rm(predictors, lm_all_wide)

```

# Map Cant

## Deep water

## Apply MLRs to predictor

```{r calculate_Cant}

Cant <- Cant %>% 
  mutate(Cant = `delta_coeff_(Intercept)` +
           delta_coeff_aou * aou +
           delta_coeff_oxygen * oxygen +
           delta_coeff_phosphate * phosphate +
           delta_coeff_phosphate_star * phosphate_star +
           delta_coeff_silicate * silicate +
           delta_coeff_sal * sal + 
           delta_coeff_tem * tem)

```

```{r calculate_predictor_contributions_to_Cant}

Cant <- Cant %>% 
  mutate(Cant_intercept = `delta_coeff_(Intercept)`,
         Cant_aou = delta_coeff_aou * aou,
         Cant_oxygen = delta_coeff_oxygen * oxygen,
         Cant_phosphate = delta_coeff_phosphate * phosphate,
         Cant_phosphate_star = delta_coeff_phosphate_star * phosphate_star,
         Cant_silicate = delta_coeff_silicate * silicate,
         Cant_sal = delta_coeff_sal * sal,
         Cant_tem = delta_coeff_tem * tem,
         Cant_sum = Cant_intercept +
           Cant_aou +
           Cant_oxygen +
           Cant_phosphate +
           Cant_phosphate_star +
           Cant_silicate + 
           Cant_sal +
           Cant_tem)

```

### Sections by model

Zonal sections plots are produced for every 20° longitude, each era and for all models individually and can be downloaded [here](https://github.com/jens-daniel-mueller/Cant_eMLR/tree/master/output/figure/mapping){target="_blank"}.


```{r Cant_section_by_model_eras_lon, eval=FALSE}

library(scales)

for (i_eras in unique(Cant$eras)) {
  # i_eras <- unique(Cant$eras)[2]
  Cant_eras <- Cant %>%
    filter(eras == i_eras)
  
  for (i_lon in seq(20.5, 360, 20)) {
    # i_lon <- seq(20.5, 360, 20)[7]
    Cant_eras_lon <- Cant_eras %>%
      filter(lon == i_lon)
    
    Cant_eras_lon %>%
      ggplot(aes(lat, depth, col = Cant)) +
      geom_point() +
      scale_color_gradient2(
        name = "Cant",
        high = muted("red"),
        mid = "grey",
        low = muted("blue")
      ) +
      scale_y_reverse(limits = c(parameters$inventory_depth, NA)) +
      scale_x_continuous(limits = c(-75, 65)) +
      coord_cartesian(expand = 0) +
      guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
      labs(title = paste("eras:", i_eras, "| lon:", i_lon)) +
      facet_wrap( ~ model, ncol = 5)
    
    ggsave(
      here::here(
        "output/figure/mapping",
        paste(i_eras,
              "lon",
              i_lon,
              "model_Cant.png",
              sep = "_")
      ),
      width = 17,
      height = 9
    )
    
  }
}

```


## Surface water

As outlined in Gruber et al. (2019), a transient equilibrium approach was applied to estimate Cant in surface waters, assuming that the CO2 system in these waters has followed the increase in atmospheric CO2 closely. 

Using eq 10.2.16 from OBD, the change in anthropogenic CO2 in the upper ocean was computed as:

ΔtCanteq(t2ref − t1ref )= 1∕γ ⋅ DIC/pCO2 ⋅ (pCO2atm (t2ref)− pCO2atm (t1ref))

, where DIC and pCO2 are the in situ values, where γ is the buffer (Revelle) factor and where we evaluated the right-hand side using seacarb employing the Mehrbach constants as refitted by Dickson and Millero using the climatological values for temperature, salinity, DIC and Alk.

### pCO2 climatology

```{r pCO2_climatology}

predictors_surface <- predictors_surface %>% 
  mutate(pCO2 = carb(flag = 15,
                     var1 = TAlk*1e-6,
                     var2 = TCO2*1e-6,
                     S = sal,
                     T = tem,
                     P = depth/10,
                     Pt = PO4*1e-6,
                     Sit = silicate*1e-6,
                     k1k2 = "l")$pCO2)

map_climatology(predictors_surface, "pCO2")

section_global_surface(predictors_surface, "pCO2")


```

### Revelle factor

```{r revelle_factor_climatology}

predictors_surface <- predictors_surface %>% 
  mutate(rev_fac = buffer(flag = 15,
                     var1 = TAlk*1e-6,
                     var2 = TCO2*1e-6,
                     S = sal,
                     T = tem,
                     P = depth/10,
                     Pt = PO4*1e-6,
                     Sit = silicate*1e-6,
                     k1k2 = "l")$BetaD)

map_climatology(predictors_surface, "rev_fac")

section_global_surface(predictors_surface, "rev_fac")

```

### Cant

```{r Cant_surface}

co2_atm_tref <- co2_atm_tref %>% 
  arrange(pCO2_tref) %>% 
  mutate(d_pCO2_tref = pCO2_tref - lag(pCO2_tref)) %>% 
  drop_na() %>% 
  mutate(eras = c("JGOFS_GO", "GO_new")) %>% 
  select(eras, d_pCO2_tref)

Cant_surface <- full_join(predictors_surface, co2_atm_tref,
                          by = character())

Cant_surface <- Cant_surface %>% 
  mutate(Cant = (1 / rev_fac) * (TCO2 / pCO2) * d_pCO2_tref)

map_climatology_eras(Cant_surface, "Cant")

section_global_surface_eras(Cant_surface, "Cant")

```


## Mean Cant fields

Mean and sd are calculated for Cant in each grid cell (XYZ), basin and era combination. Calculations are performed for all Cant values vs positive values only. This averaging step summarizes the information derived from ten best fitting MLRs. 

### Deep water averaging

```{r Calculate_Cant_mean}

Cant_predictor_average <- Cant %>%
  mutate(Cant_pos = if_else(Cant < 0, 0, Cant)) %>%
  group_by(lon, lat, depth, eras, basin) %>%
  summarise(Cant_intercept = mean(Cant_intercept, na.rm = TRUE),
            Cant_aou = mean(Cant_aou, na.rm = TRUE),
            Cant_oxygen = mean(Cant_oxygen, na.rm = TRUE),
            Cant_phosphate = mean(Cant_phosphate, na.rm = TRUE),
            Cant_phosphate_star = mean(Cant_phosphate_star, na.rm = TRUE),
            Cant_silicate = mean(Cant_silicate, na.rm = TRUE),
            Cant_tem = mean(Cant_tem, na.rm = TRUE),
            Cant_sal = mean(Cant_sal, na.rm = TRUE),
            Cant_sum = mean(Cant_sum, na.rm = TRUE),
            gamma_mean = mean(gamma, na.rm = TRUE)
            ) %>%
  ungroup()

Cant_predictor_average_Atl <- Cant_predictor_average %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Atl))

Cant_predictor_average_Ind_Pac <- Cant_predictor_average %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Ind_Pac))

Cant_predictor_average <- bind_rows(Cant_predictor_average_Atl, Cant_predictor_average_Ind_Pac)

rm(Cant_predictor_average_Atl, Cant_predictor_average_Ind_Pac)

# Cant <- Cant %>%
#   select(lon, lat, depth, eras, basin, Cant, gamma, model)

Cant <- Cant %>%
  mutate(Cant_pos = if_else(Cant < 0, 0, Cant))

Cant_average <- Cant %>%
  group_by(lon, lat, depth, eras, basin) %>%
  summarise(Cant_mean = mean(Cant, na.rm = TRUE),
            Cant_sd = sd(Cant, na.rm = TRUE),
            Cant_pos_mean = mean(Cant_pos, na.rm = TRUE),
            Cant_pos_sd = sd(Cant_pos, na.rm = TRUE),
            gamma_mean = mean(gamma, na.rm = TRUE),
            gamma_sd = sd(gamma, na.rm = TRUE)) %>%
  ungroup()

# for (i_basin in unique(Cant$basin)) {
#   for (i_eras in unique(Cant$eras)) {
#     for (i_depth in unique(Cant$depth)) {
#       
#       # i_basin <- unique(Cant$basin)[1]
#       # i_eras  <- unique(Cant$eras) [1]
#       # i_depth <- unique(Cant$depth)[1]
#       # print(i_basin)
#       # print(i_eras)
#       # print(i_depth)
#       
#       temp <- Cant %>%
#         filter(basin == i_basin,
#                eras == i_eras,
#                depth == i_depth) %>%
#         group_by(lon, lat) %>%
#         summarise(
#           Cant_mean = mean(Cant, na.rm = TRUE),
#           Cant_sd = sd(Cant, na.rm = TRUE),
#           Cant_pos_mean = mean(Cant_pos, na.rm = TRUE),
#           Cant_pos_sd = sd(Cant_pos, na.rm = TRUE),
#           gamma_mean = mean(gamma, na.rm = TRUE),
#           gamma_sd = sd(gamma, na.rm = TRUE)
#         ) %>%
#         ungroup()
#       
#       if (exists("Cant_average")) {
#         Cant_average <- bind_rows(Cant_average, temp)
#       }
#       
#       if (!exists("Cant_average")) {
#         Cant_average <- temp
#       }
#       
#     }
#     
#   }
#   
# } 

rm(Cant)

```

### Join surface and deep water

```{r join_surface_deep_cant}

Cant_surface <- Cant_surface %>%
  mutate(Cant_pos = if_else(Cant < 0, 0, Cant)) %>%
  group_by(lon, lat, depth, eras, basin) %>%
  summarise(Cant_mean = mean(Cant, na.rm = TRUE),
            Cant_sd = sd(Cant, na.rm = TRUE),
            Cant_pos_mean = mean(Cant_pos, na.rm = TRUE),
            Cant_pos_sd = sd(Cant_pos, na.rm = TRUE),
            gamma_mean = mean(gamma, na.rm = TRUE),
            gamma_sd = sd(gamma, na.rm = TRUE)) %>%
  ungroup()

Cant_average <- full_join(Cant_average, Cant_surface)

```

### Gamma slab zonal mean

```{r calculate_gamma_slab_zonal_mean}

Cant_average_Atl <- Cant_average %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Atl))

Cant_average_Ind_Pac <- Cant_average %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Ind_Pac))

Cant_average <- bind_rows(Cant_average_Atl, Cant_average_Ind_Pac)

rm(Cant_average_Atl, Cant_average_Ind_Pac)

```


## Mean Cant sections

For each basin and era combination, the zonal mean Cant is calculated, again for all vs positive only values. Likewise, sd is calculated for the averaging of the mean basin fields.

```{r Calculate_Cant_mean_sections}


Cant_average <- left_join(Cant_average,
                          basinmask_AIP %>% select(-basin))

Cant_average_zonal <- Cant_average %>%
  group_by(lat, depth, eras, basin, basin_AIP) %>%
  summarise(across(
    c(
      "Cant_mean",
      "Cant_pos_mean",
      "Cant_sd",
      "Cant_pos_sd",
      "gamma_mean",
      "gamma_sd"
    ),
    list(
      mean = ~ mean(.x, na.rm = TRUE),
      sd = ~ sd(.x, na.rm = TRUE)
    )
  )) %>%
  ungroup()


# Cant_average_zonal <- Cant_average %>% 
#   group_by(lat, depth, eras, basin) %>% 
#   summarise(Cant_mean_sd = sd(Cant_mean, na.rm = TRUE),
#             Cant_mean = mean(Cant_mean, na.rm = TRUE),
#             Cant_sd_mean = mean(Cant_sd, na.rm = TRUE),
#             Cant_pos_mean_sd = sd(Cant_pos_mean, na.rm = TRUE),
#             Cant_pos_mean = mean(Cant_pos_mean, na.rm = TRUE),
#             Cant_pos_sd_mean = mean(Cant_pos_sd, na.rm = TRUE),
#             gamma_mean = mean(gamma_mean)) %>% 
#   ungroup()


Cant_average_zonal_Atl <- Cant_average_zonal %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma_mean_mean, parameters$slabs_Atl))

Cant_average_zonal_Ind_Pac <- Cant_average_zonal %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma_mean_mean, parameters$slabs_Ind_Pac))

Cant_average_zonal <- bind_rows(Cant_average_zonal_Atl, Cant_average_zonal_Ind_Pac)

rm(Cant_average_zonal_Atl, Cant_average_zonal_Ind_Pac)

```

## Mean Cant sections by coefficient

For each basin and era combination, the zonal mean Cant is calculated by model coefficient.

```{r Calculate_Cant_predictor_mean_sections}

Cant_predictor_average <- full_join(Cant_predictor_average,
                                basinmask_AIP %>% select(-basin))

Cant_predictor_average_zonal <- Cant_predictor_average %>%
  group_by(lat, depth, eras, basin, basin_AIP) %>%
  summarise(across(
    Cant_intercept:gamma_mean,
    list(mean = ~ mean(.x, na.rm = TRUE))
  )) %>%
  ungroup()


# Cant_average_zonal <- Cant_average %>% 
#   group_by(lat, depth, eras, basin) %>% 
#   summarise(Cant_mean_sd = sd(Cant_mean, na.rm = TRUE),
#             Cant_mean = mean(Cant_mean, na.rm = TRUE),
#             Cant_sd_mean = mean(Cant_sd, na.rm = TRUE),
#             Cant_pos_mean_sd = sd(Cant_pos_mean, na.rm = TRUE),
#             Cant_pos_mean = mean(Cant_pos_mean, na.rm = TRUE),
#             Cant_pos_sd_mean = mean(Cant_pos_sd, na.rm = TRUE),
#             gamma_mean = mean(gamma_mean)) %>% 
#   ungroup()


Cant_predictor_average_zonal_Atl <- Cant_predictor_average_zonal %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma_mean_mean, parameters$slabs_Atl))

Cant_predictor_average_zonal_Ind_Pac <- Cant_predictor_average_zonal %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma_mean_mean, parameters$slabs_Ind_Pac))

Cant_predictor_average_zonal <- bind_rows(Cant_predictor_average_zonal_Atl, Cant_predictor_average_zonal_Ind_Pac)

rm(Cant_predictor_average_zonal_Atl, Cant_predictor_average_zonal_Ind_Pac)

```

## Inventory calculation

To calculate Cant column inventories, we:  

1. Multiple layer thickness with Cant concentration to get a layer inventory
2. For each horizontal grid cell and era, sum Cant layer inventories from 150 - 3000 m

Step 2 is performed again for all Cant and positive Cant values only

```{r calculate_inventories}

depth_level_volume <- tibble(depth = unique(Cant_average$depth)) %>% 
  arrange(depth)

depth_level_volume <- depth_level_volume %>%
  mutate(
    layer_thickness_above = replace_na((depth - lag(depth)) / 2, 0),
    layer_thickness_below = replace_na((lead(depth) - depth) / 2, 0),
    layer_thickness = layer_thickness_above + layer_thickness_below
  ) %>%
  select(-c(layer_thickness_above,
            layer_thickness_below))

depth_level_volume %>% 
  ggplot(aes(depth, layer_thickness)) + 
  geom_point()

Cant_average <-
  full_join(Cant_average, depth_level_volume)

Cant_average <- Cant_average %>%
  mutate(layer_inv = Cant_mean * layer_thickness) %>%
  mutate(layer_inv_pos = if_else(layer_inv < 0, 0, layer_inv)) %>%
  select(-layer_thickness)

Cant_inv <- Cant_average %>%
  group_by(lon, lat, basin, eras) %>%
  summarise(
    cant_inv_pos = sum(layer_inv_pos, na.rm = TRUE) / 1000,
    cant_inv     = sum(layer_inv, na.rm = TRUE) / 1000
  ) %>%
  ungroup()


```


# Write csv

```{r write_cant_files}

# Cant %>%
#     write_csv(here::here("data/mapping/_summarized_files",
#                          "Cant.csv"))

Cant_average %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_average.csv"))

Cant_predictor_average %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_predictor_average.csv"))

Cant_average_zonal %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_average_zonal.csv"))

Cant_predictor_average_zonal %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_predictor_average_zonal.csv"))

Cant_inv %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_inv.csv"))

rm(Cant_average,
   Cant_predictor_average,
   Cant_average_zonal,
   Cant_predictor_average_zonal,
   Cant_inv)

```


