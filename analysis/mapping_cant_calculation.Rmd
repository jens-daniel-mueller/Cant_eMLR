---
title: "Mapping"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r library, message=FALSE, warning=FALSE}
library(tidyverse)
library(metR)
# library(lubridate)
# library(oce)
# library(marelac)
# library(reticulate)

```

```{r read_parameters, include = FALSE}

parameters <-
  read_rds(here::here("data",
                       "parameters.rds"))
```

```{r read_mask_files}

basinmask <- read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                                 "basin_mask_WOA18.csv"))

landmask <- read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                                 "land_mask_WOA18.csv"))

```

```{r read_parameters_functions, include = FALSE}
source(here::here("code", "plotting_functions.R"))
```

```{r ggplot_theme, include = FALSE}
theme_set(theme_bw())
```

# Predictor fields

Currently, we use combined predictor fields:

- WOA18: S, T, and derived variables
- GLODAP16: Oxygen, PO4, NO3, Silicate, and derived variables

```{r read_predictor_file}

predictors <- 
    read_csv(here::here("data/mapping/predictor_fields",
                         "W18_st_G16_opsn.csv"))

```

# Select phosphate star

Currently, mapping of Cant is based on PO4* calculated with:  

- `r parameters$phosphate_star_approach`

```{r select_phosphate_star_aproach}

if (parameters$phosphate_star_approach == "nitrate") {
  predictors <- predictors %>%
    mutate(phosphate_star = phosphate_star_nit) %>%
    select(-c(phosphate_star_oxy, phosphate_star_nit))
} else{
  predictors <- predictors %>%
    mutate(phosphate_star = phosphate_star_oxy) %>%
    select(-c(phosphate_star_oxy, phosphate_star_nit))
}
```


# Apply spatial boundaries

Only predictors were taken into consideration with:

- minimum sampling depth:  `r parameters$depth_min`m
- minimum bottom depth:  `r parameters$bottomdepth_min`m
- maximum latitude:  `r parameters$lat_max`°N


```{r apply_spatial_boundaries}

predictors <- predictors %>% 
  filter(depth >= parameters$depth_min)

predictors <- predictors %>% 
  filter(lat <= parameters$lat_max)

predictors_grid <- predictors %>% 
  group_by(lat, lon) %>% 
  summarise(bottomdepth = max(depth)) %>% 
  ungroup()

predictors <- full_join(predictors, predictors_grid)

predictors <- predictors %>% 
  filter(bottomdepth >= parameters$bottomdepth_min) %>% 
  select(-bottomdepth)

predictors <- predictors %>% drop_na()

```

# Load MLR models

```{r load_eMLR_models}

all_lm_wide <-
  read_csv(here::here("data/eMLR",
                       "all_lm_wide.csv"))

```

# Merge MLRs + climatologies

```{r merge_model_coeff_predictor_climatology}

all_lm_wide <- all_lm_wide %>% 
  mutate(model = str_remove(model, "Cstar ~ "))
         
Cant <- full_join(predictors, all_lm_wide)
#rm(predictors, all_lm_wide)

```

# Map Cant

## Apply MLRs to predictor

```{r calculate_Cant}

Cant <- Cant %>% 
  mutate(Cant = `delta_coeff_(Intercept)` +
           delta_coeff_aou * aou +
           delta_coeff_oxygen * oxygen +
           delta_coeff_phosphate * phosphate +
           delta_coeff_phosphate_star * phosphate_star +
           delta_coeff_silicate * silicate +
           delta_coeff_sal * sal + 
           delta_coeff_tem * tem)

```

## Mean Cant fields

Mean and sd are calculated for Cant in each grid cell (XYZ), basin and era combination. Calculations are performed for all Cant values vs positive values only. This averaging step summarizes the information derived from ten best fitting MLRs. 

```{r Calculate_Cant_mean}

Cant <- Cant %>%
  select(lon, lat, depth, eras, basin, Cant, gamma, model)

# Cant_average <- Cant %>%
#   mutate(Cant_pos = if_else(Cant < 0, 0, Cant)) %>%
#   group_by(lon, lat, depth, eras, basin) %>%
#   summarise(across(c("Cant", "Cant_pos", "gamma"),
#                    list(
#                      mean = ~ mean(.x, na.rm = TRUE),
#                      sd = ~ sd(.x, na.rm = TRUE)
#                    ))) %>%
#   ungroup()

Cant_average <- Cant %>%
  mutate(Cant_pos = if_else(Cant < 0, 0, Cant)) %>%
  group_by(lon, lat, depth, eras, basin) %>%
  summarise(Cant_mean = mean(Cant, na.rm = TRUE),
            Cant_sd = sd(Cant, na.rm = TRUE),
            Cant_pos_mean = mean(Cant_pos, na.rm = TRUE),
            Cant_pos_sd = sd(Cant_pos, na.rm = TRUE),
            gamma_mean = mean(gamma, na.rm = TRUE),
            gamma_sd = sd(gamma, na.rm = TRUE)) %>%
  ungroup()

Cant_average_Atl <- Cant_average %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Atl))

Cant_average_Ind_Pac <- Cant_average %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Ind_Pac))

Cant_average <- bind_rows(Cant_average_Atl, Cant_average_Ind_Pac)

rm(Cant_average_Atl, Cant_average_Ind_Pac)

```

## Mean Cant sections

For each basin and era combination, the zonal mean Cant is calculated, again for all vs positive only values. Likewise, sd is calculated for the averaging of the mean basin fields.

```{r Calculate_Cant_mean_sections}

Cant_average <- full_join(Cant_average,
                                basinmask %>% select(-basin))

Cant_average_zonal <- Cant_average %>%
  group_by(lat, depth, eras, basin, basin_AIP) %>%
  summarise(across(
    c(
      "Cant_mean",
      "Cant_pos_mean",
      "Cant_sd",
      "Cant_pos_sd",
      "gamma_mean",
      "gamma_sd"
    ),
    list(mean = ~ mean(.x, na.rm = TRUE),
         sd = ~ sd(.x, na.rm = TRUE))
  )) %>%
  ungroup()


# Cant_average_zonal <- Cant_average %>% 
#   group_by(lat, depth, eras, basin) %>% 
#   summarise(Cant_mean_sd = sd(Cant_mean, na.rm = TRUE),
#             Cant_mean = mean(Cant_mean, na.rm = TRUE),
#             Cant_sd_mean = mean(Cant_sd, na.rm = TRUE),
#             Cant_pos_mean_sd = sd(Cant_pos_mean, na.rm = TRUE),
#             Cant_pos_mean = mean(Cant_pos_mean, na.rm = TRUE),
#             Cant_pos_sd_mean = mean(Cant_pos_sd, na.rm = TRUE),
#             gamma_mean = mean(gamma_mean)) %>% 
#   ungroup()


Cant_average_zonal_Atl <- Cant_average_zonal %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma_mean_mean, parameters$slabs_Atl))

Cant_average_zonal_Ind_Pac <- Cant_average_zonal %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma_mean_mean, parameters$slabs_Ind_Pac))

Cant_average_zonal <- bind_rows(Cant_average_zonal_Atl, Cant_average_zonal_Ind_Pac)

rm(Cant_average_zonal_Atl, Cant_average_zonal_Ind_Pac)

```

## Inventory calculation

To calculate Cant column inventories, we:  

1. Multiple layer thickness with Cant concentration to get a layer inventory
2. For each horizontal grid cell and era, sum Cant layer inventories from 150 - 3000 m

Step 2 is performed again for all Cant and positive Cant values only

```{r calculate_inventories}

depth_level_volume <- tibble(depth = unique(Cant_average$depth))

depth_level_volume <- depth_level_volume %>%
  mutate(
    layer_thickness_above = replace_na((depth - lag(depth)) / 2, 0),
    layer_thickness_below = replace_na((lead(depth) - depth) / 2, 0),
    layer_thickness = layer_thickness_above + layer_thickness_below
  ) %>%
  select(-c(layer_thickness_above,
            layer_thickness_below))

Cant_average <-
  full_join(Cant_average, depth_level_volume)

Cant_average <- Cant_average %>%
  mutate(layer_inv = Cant_mean * layer_thickness) %>%
  mutate(layer_inv_pos = if_else(layer_inv < 0, 0, layer_inv)) %>%
  select(-layer_thickness)

Cant_inv <- Cant_average %>%
  filter(depth <= parameters$inventory_depth) %>%
  group_by(lon, lat, basin, eras) %>%
  summarise(
    cant_inv_pos = sum(layer_inv_pos, na.rm = TRUE) / 1000,
    cant_inv     = sum(layer_inv, na.rm = TRUE) / 1000
  ) %>%
  ungroup()


```


# Write csv

```{r write_cant_files}

Cant %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant.csv"))

Cant_average %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_average.csv"))

Cant_average_zonal %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_average_zonal.csv"))

Cant_inv %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_inv.csv"))

```


# Open tasks

- 

# Open questions

- 
