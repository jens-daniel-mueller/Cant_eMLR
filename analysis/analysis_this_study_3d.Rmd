---
title: "Analysis of Cant estimates - 3d vis"
author: "Jens Daniel MÃ¼ller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r library, message=FALSE, warning=FALSE}
library(tidyverse)
library(patchwork)
library(scico)
library(scales)
library(metR)
library(marelac)
library(kableExtra)
library(threejs)
```


```{r read_parameters, include = FALSE}
parameters <-
  read_rds(here::here("data",
                       "parameters.rds"))

slab_breaks <- c(parameters$slabs_Atl[1:12],Inf)
```

```{r read_mask_files, include = FALSE}
basinmask <-
  read_csv(
    here::here(
      "data/World_Ocean_Atlas_2018/_summarized_files",
      "basin_mask_WOA18.csv"
    )
  )
basinmask_AIP <-
  read_csv(
    here::here(
      "data/World_Ocean_Atlas_2018/_summarized_files",
      "basin_mask_WOA18_AIP.csv"
    )
  )
landmask <-
  read_csv(
    here::here(
      "data/World_Ocean_Atlas_2018/_summarized_files",
      "land_mask_WOA18.csv"
    )
  )

section_global_coordinates <-
  read_csv(here::here("data",
                       "section_global_coordinates.csv"))
```

```{r read_functions, include = FALSE}
source(here::here("code", "plotting_functions.R"))
```

```{r ggplot_theme, include = FALSE}
theme_set(theme_bw())
```

# Data sources

Cant estimates from this study:

- Mean and SD per grid cell (lat, lon, depth)
- Zonal mean and SD (basin, lat, depth)
- Inventories (lat, lon)


```{r read_cant_files}


Cant_average <-
  read_csv(here::here("data/mapping/_summarized_files",
                         "Cant_average.csv"))

Cant_average_zonal <-
  read_csv(here::here("data/mapping/_summarized_files",
                         "Cant_average_zonal.csv"))

Cant_predictor_average_zonal <-
  read_csv(here::here("data/mapping/_summarized_files",
                         "Cant_predictor_average_zonal.csv"))

Cant_inv <-
  read_csv(here::here("data/mapping/_summarized_files",
                         "Cant_inv.csv"))

```

C* estimates from this study:

- Mean and SD per grid cell (lat, lon, depth)
- Zonal mean and SD (basin, lat, depth)

```{r read_cstar_files}


Cstar_average <-
  read_csv(here::here("data/mapping/_summarized_files",
                         "Cstar_average.csv"))

Cstar_average_zonal <-
  read_csv(here::here("data/mapping/_summarized_files",
                         "Cstar_average_zonal.csv"))


```

Cleaned GLODAPv2_2020 file as used in this study

```{r read_GLODAP_used_for_fitting}

GLODAP <-
  read_csv(
    here::here(
      "data/GLODAPv2_2020/_summarized_data_files",
      "GLODAP_MLR_fitting_ready.csv"
    )
  )

```

# Color scale

For ease of comparison with Gruber et al (2019) we adapt their color scale, including the ranges and breaks applied in various types of visualizations.

```{r define_Gruber_rainbow}

rgb2hex <- function(r, g, b)
  rgb(r, g, b, maxColorValue = 100)

cols = c(rgb2hex(95, 95, 95),
         rgb2hex(0, 0, 95),
         rgb2hex(100, 0, 0),
         rgb2hex(100, 100, 0))

Gruber_rainbow <- colorRampPalette(cols)

rm(rgb2hex, cols)

```

# Cant budgets

Global Cant inventories were estimated in Pg-C. Please note that here we only added positive Cant values in the upper `r parameters$inventory_depth`m and do not apply additional corrections for areas not covered.

```{r calculate_global_inventory}

Cant_inv <- left_join(Cant_inv, basinmask_AIP) 

Cant_inv_budget <- Cant_inv %>% 
  mutate(surface_area = earth_surf(lat, lon),
         cant_inv_grid = cant_inv*surface_area) %>% 
  group_by(eras, basin_AIP) %>% 
  summarise(cant_total = sum(cant_inv_grid)*12*1e-15,
            cant_total = round(cant_total,1)) %>% 
  ungroup() %>% 
  arrange(desc(eras)) %>% 
  pivot_wider(values_from = cant_total, names_from = basin_AIP) %>% 
  mutate(total = Atlantic + Indian + Pacific)

Cant_inv_budget %>% 
  kableExtra::kable() %>% 
  add_header_above() %>%
  kable_styling(full_width = FALSE)

rm(Cant_inv_budget)

```



# Cant - positive

In a first series of plots we explore the distribution of Cant, taking only positive estimates into account (positive here refers to the mean Cant estimate across 10 eMLR model predictions available for each grid cell). Negative values were set to zero before calculating mean sections and inventories.

## Inventory

### Map

Column inventory of positive Cant between the surface and `r parameters$inventory_depth`m water depth per horizontal grid cell (lat x lon).

```{r Cant_pos_inventory_map, fig.asp=1}

breaks <- c(seq(0,16,2),Inf)
breaks_n <- length(breaks) - 1

Cant_inv <- Cant_inv %>% 
  mutate(cant_inv_pos_int = cut(cant_inv_pos, 
                                breaks,
                                right = FALSE)) %>% 
  mutate(eras = factor(eras, c("JGOFS_GO", "GO_new")))

Cant_inv %>%
  ggplot() +
  geom_raster(data = landmask,
              aes(lon, lat), fill = "grey30") +
  geom_raster(aes(lon, lat, fill = cant_inv_pos_int)) +
  coord_quickmap(expand = 0) +
  scale_fill_manual(values = Gruber_rainbow(breaks_n)) +
  # scale_fill_scico_d(palette = "batlow", direction = -1) +
  facet_wrap( ~ eras, ncol = 1) +
  theme(axis.title = element_blank())

```

### Interactive Globe

#### JGOGS_GO eras

```{r Cant_pos_inventory_globe_JGOFS_GO, fig.asp=1}

x <- Cant_inv %>%
  filter(eras == "JGOFS_GO") %>%
  select(lon, lat, cant_inv_pos) %>%
  mutate(cant_col = as.character(cut(
    cant_inv_pos,
    breaks,
    Gruber_rainbow(breaks_n)
  )))


globejs(
  lat = x$lat,
  long = x$lon,
  color = x$cant_col,
  val = 0,
  pointsize = 2,
  bg = "white",
  rotationlong = -0.8,
  rotationlat = 0.3
)

rm(x)

```

#### GO_new eras

```{r Cant_pos_inventory_globe_GO_new, fig.asp=1}

x <- Cant_inv %>%
  filter(eras == "GO_new") %>%
  select(lon, lat, cant_inv_pos) %>%
  mutate(cant_col = as.character(cut(
    cant_inv_pos,
    breaks,
    Gruber_rainbow(breaks_n)
  )))


globejs(
  lat = x$lat,
  long = x$lon,
  color = x$cant_col,
  val = 0,
  pointsize = 2,
  bg = "white",
  rotationlong = -0.8,
  rotationlat = 0.3
)

rm(breaks, breaks_n, x)

```



