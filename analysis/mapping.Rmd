---
title: "Mapping"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r library, message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(oce)
library(marelac)
library(metR)

```


```{r ggplot_theme, include = FALSE}
theme_set(theme_bw())
```

# Required data

Currently we use following data sets for mapping: 

- GLODAPv2_2016b_MappedClimatologies
  - Salinity
  - Temperature
  - Phosphate
  - Nitrate
  - Silicate
  - oxygen
- World Ocean Atlas 2013
  - Neutral densities calculated by D Clement
- World Ocean Atlas 2018
  - basin mask
- eMLR model coefficients

We aim to use WOA18 instead of WOA13, but still need to implement neutral density calculation.

```{r load_GLODAPv2_2016b_MappedClimatologies}

variables <- c("salinity", "temperature", "NO3", "oxygen", "PO4", "silicate")

for (i_variable in variables) {
  
  # i_variable <- variables[2]
  # print(i_variable)
  temp <- read_csv(
    here::here("data/GLODAPv2_2016b_MappedClimatologies/_summarized_files",
               paste(i_variable,".csv", sep = "")))
  
  if (exists("GLODAP_predictors")) {
     GLODAP_predictors <- full_join(GLODAP_predictors, temp)
  }
  
  if (!exists("GLODAP_predictors")) {
    GLODAP_predictors <- temp
  }

}

rm(temp, i_variable, variables)

# GLODAP_depths <- unique(GLODAP_predictors$depth)
# GLODAP_lon <- unique(GLODAP_predictors$lon)
# min(GLODAP_lon)
# max(GLODAP_lon)

```

```{r load_WOA18, eval=FALSE}

WOA18_predictors <-
  read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                       "WOA18_predictors.csv"))

WOA18_predictors <- WOA18_predictors %>% 
  rename(salinity = s_an, temperature = t_an)

# WOA18_depths <- unique(WOA18_predictors$depth)


```

```{r load_WOA13_gamma}

WOA13 <-
  read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                       "WOA13_mask_gamma.csv"))

WOA13_gamma <- WOA13 %>% 
  select(-mask)

WOA13_gamma <- WOA13_gamma %>% 
  rename(lat = latitude, lon = longitude) %>% 
  mutate(lon = if_else(lon > 180, lon - 360, lon))

rm(WOA13)

# WOA13_depths <- unique(WOA13_gamma$depth)
# GLODAP_depths - WOA13_depths

```


```{r read_basin_mask_file}

basinmask <- read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                                 "basin_mask_WOA18.csv"))

```


```{r load_eMLR_coeffcients}

all_lm <- read_csv(here::here("data/eMLR",
                              "all_lm.csv"))

```



# Join predictor climatologies

**CAVEAT**: Coverage of GLODAP climatologies differs slightly for parameters (some are NA in some regions)

## Control plots

Maps of number of observations per horizontal grid cell.

### GLODAP climatology

```{r control_plots_pre_merging_GLODAP}

GLODAP_n <- GLODAP_predictors %>% 
  drop_na() %>% 
  group_by(lat, lon) %>% 
  summarise(n = n()) %>% 
  ungroup()

GLODAP_n %>%
  ggplot(aes(lon, lat, fill = n)) +
  geom_raster() +
  scale_fill_viridis_c(direction = -1) +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom")

rm(GLODAP_n)

```

### WOA13 climatology

```{r control_plots_pre_merging_WOA13}

WOA13_gamma_n <- WOA13_gamma %>% 
  drop_na() %>% 
  group_by(lat, lon) %>% 
  summarise(n = n()) %>% 
  ungroup()

WOA13_gamma_n %>%
  ggplot(aes(lon, lat, fill = n)) +
  geom_raster() +
  scale_fill_viridis_c(direction = -1) +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom")

rm(WOA13_gamma_n)

```


## WOA13 + GLODAP

```{r join_WOA13_GLODAP_predictors}

predictors <- full_join(GLODAP_predictors, WOA13_gamma)
rm(GLODAP_predictors, WOA13_gamma)

predictors <- predictors %>% 
  group_by(lat, lon) %>% 
  mutate(n_NO3 = sum(!is.na(NO3)),
         n_oxygen = sum(!is.na(oxygen)),
         n_PO4 = sum(!is.na(PO4)),
         n_silicate = sum(!is.na(silicate)),
         n_salinity = sum(!is.na(salinity)),
         n_temperature = sum(!is.na(temperature)),
         n_gamma = sum(!is.na(gamma))) %>% 
  ungroup()

predictors <- predictors %>% 
  filter(n_NO3 > 0,
         n_oxygen > 0,
         n_PO4 > 0,
         n_silicate > 0, 
         n_salinity > 0, 
         n_temperature > 0, 
         n_gamma > 0) %>% 
  select(-c(n_NO3, 
            n_oxygen, 
            n_PO4, 
            n_silicate, 
            n_salinity, 
            n_temperature,
            n_gamma))


predictors <- predictors %>% 
  drop_na()

```

### Spatial boundaries

```{r set_criteria_spatial_boundaries}

min_depth <- 150
min_bottomdepth <- 500
max_lat <- 65

```


Only mapped variables were taken into consideration with:

- minimum depth:  `r min_depth`m
- minimum bottom depth:  `r min_bottomdepth`m
- maximum latitude:  `r max_lat`°N


```{r apply_spatial_boundaries}

predictors <- predictors %>% 
  filter(depth >= min_depth)

predictors <- predictors %>% 
  filter(lat <= max_lat)

predictors <- predictors %>% 
  group_by(lat, lon) %>% 
  mutate(bottomdepth = max(depth)) %>% 
  ungroup()

predictors <- predictors %>% 
  filter(bottomdepth >= min_bottomdepth) %>% 
  select(-bottomdepth)

rm(min_depth, max_lat, min_bottomdepth)

```

### Basin mask

Please note that some predictor variables are available outside the WOA18 basin mask and will be removed for further analysis.

```{r join_basin_mask}

predictors <- inner_join(predictors, basinmask)
rm(basinmask)

```

### Maps

```{r WOA13_GLODAP_climatology_control_plots}

predictors %>%
  ggplot(aes(lon, lat)) +
  geom_bin2d(binwidth = c(1,1)) +
  scale_fill_viridis_c(direction = -1) +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom")

predictors %>%
  filter(depth == 150) %>% 
  ggplot(aes(lon, lat, fill = PO4)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom") +
  labs(title = "150m values")

predictors %>%
  filter(depth == 150) %>% 
  ggplot(aes(lon, lat, fill = gamma)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom") +
  labs(title = "150m values")

```


### Predictor profiles

```{r predictor_profiles_N_Atl, fig.asp=2}

N_Atl <- predictors %>% 
  filter(lat == 40.5, lon == -20.5)

N_Atl <- N_Atl %>% 
  pivot_longer(salinity:gamma, names_to = "parameter", values_to = "value")

N_Atl %>% 
  ggplot(aes(value, depth)) +
  geom_path() +
  geom_point() +
  scale_y_reverse() +
  facet_wrap(~parameter,
             scales = "free_x",
             ncol = 2)

rm(N_Atl)

```


## WOA18 + GLODAP

WOA18 data are currently not used. Code chunks in this section are not executed.

```{r join_WOA18_GLODAP_predictors, fig.asp=0.5, eval=FALSE}

predictors <- full_join(GLODAP_predictors, WOA18_predictors)
rm(GLODAP_predictors, WOA18_predictors)

predictors <- predictors %>% 
  group_by(lat, lon) %>% 
  mutate(n_NO3 = sum(!is.na(NO3)),
         n_oxygen = sum(!is.na(oxygen)),
         n_PO4 = sum(!is.na(PO4)),
         n_silicate = sum(!is.na(silicate)),
         n_salinity = sum(!is.na(salinity)),
         n_temperature = sum(!is.na(temperature))) %>% 
  ungroup()

predictors <- predictors %>% 
  filter(n_NO3 > 1,
         n_oxygen > 1,
         n_PO4 > 1,
         n_silicate > 1, 
         n_salinity > 1, 
         n_temperature > 1) %>% 
  select(-c(n_NO3 , n_oxygen , n_PO4 , n_silicate , n_salinity , n_temperature))

predictors %>%
  ggplot(aes(lon, lat)) +
  geom_bin2d(binwidth = c(1,1)) +
  scale_fill_viridis_c(direction = -1) +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom")

predictors %>%
  filter(depth == 0) %>% 
  ggplot(aes(lon, lat, fill = PO4)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom") +
  labs(title = "Surface values")

predictors %>%
  filter(depth == 0) %>% 
  ggplot(aes(lon, lat, fill = temperature)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom") +
  labs(title = "Surface values")


```

```{r interpolate_WOA18_vertically, eval=FALSE}

predictors <- predictors %>% 
  group_by(lat, lon) %>% 
  arrange(depth) %>% 
  mutate(temperature = approxfun(depth, temperature, rule = 2)(depth),
         salinity = approxfun(depth, salinity, rule = 2)(depth)) %>% 
  ungroup()


predictors <- predictors %>% 
  filter(depth %in% GLODAP_depths)


```

# Map Cant

## PO~4~* calculation 

Currently, the predictor PO~4~* is calculated according to Clement and Gruber (2018), ie based on oxygen rather than nitrate.

```{r calculate_phosphate_star_clement}

predictors <- predictors %>% 
  rename(phosphate = PO4) %>% 
  mutate(phosphate_star = phosphate + (oxygen / 170)  - 1.95)

```


## AOU climatology

### Calculation

```{r calculate_aou_climatology}

predictors <- predictors %>% 
  mutate(oxygen_sat = gas_satconc(S = salinity,
                                  t = temperature,
                                  P = 1.013253,
                                  species = "O2"),
         aou = oxygen_sat - oxygen) %>% 
  select(-oxygen_sat)


```

### Atlantic section

```{r aou_climatology_section}

Atl_lon <- 335.5 - 360

predictors %>% 
  filter(lon == Atl_lon) %>% 
  ggplot(aes(lat, depth, z = aou)) +
  geom_contour_filled() +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  theme(legend.position = "top")

rm(Atl_lon)

```

## Isoneutral slabs

```{r define_isoneutral_slabs}

slabs_Atl <- c(
-Inf,
26.00,
26.50,
26.75,
27.00,
27.25,
27.50,
27.75,
27.85,
27.95,
28.05,
28.10,
28.15,
28.20,
Inf)

slabs_Ind_Pac <- c(
-Inf,
26.00,
26.50,
26.75,
27.00,
27.25,
27.50,
27.75,
27.85,
27.95,
28.05,
28.10,
Inf)


```

The following boundaries for isoneutral slabs were defined:

- Atlantic: `r slabs_Atl`
- Indo-Pacific: `r slabs_Ind_Pac`

Continous neutral densities (gamma) values from GLODAP are grouped into isoneutral slabs.

```{r cut_isoneutral_slabs}

predictors_Atl <- predictors %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma, slabs_Atl))

predictors_Ind_Pac <- predictors %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma, slabs_Ind_Pac))

predictors <- bind_rows(predictors_Atl, predictors_Ind_Pac)

rm(predictors_Atl, predictors_Ind_Pac, slabs_Atl, slabs_Ind_Pac)

```


## Prepare model coefficients

```{r prepare_model_coefficients}

all_lm <- all_lm %>% 
  select(term, estimate, basin, era, gamma_slab, model)

all_lm <- all_lm %>% 
  mutate(estimate = if_else(is.na(estimate), 0, estimate))

all_lm_wide <- all_lm %>% 
  pivot_wider(names_from = era, values_from = estimate,
              names_prefix = "coeff_")

all_lm_wide <- all_lm_wide %>% 
  mutate(JGOFS_GO = coeff_GO_SHIP - coeff_JGOFS_WOCE,
         GO_new = coeff_new_era - coeff_GO_SHIP) %>% 
  select(-c(coeff_JGOFS_WOCE,
            coeff_GO_SHIP,
            coeff_new_era))

all_lm_long <- all_lm_wide %>% 
  pivot_longer(JGOFS_GO:GO_new, names_to = "eras", values_to = "delta_coeff")

all_lm_wide <- all_lm_long %>% 
  pivot_wider(values_from = delta_coeff,
              names_from = term,
              names_prefix = "delta_coeff_",
              values_fill = 0)

rm(all_lm_long, all_lm)

```



## Merge model + climatology

```{r merge_model_coeff_predictor_climatology}

Cant <- full_join(predictors, all_lm_wide)

rm(predictors, all_lm_wide)

```

## Calculate Cant

```{r calculate_Cant}

Cant <- Cant %>% 
  mutate(Cant = `delta_coeff_(Intercept)` +
           delta_coeff_aou * aou +
           delta_coeff_oxygen * oxygen +
           delta_coeff_phosphate * phosphate +
           delta_coeff_phosphate_star * phosphate_star +
           delta_coeff_silicate * silicate +
           delta_coeff_salinity * salinity + 
           delta_coeff_temperature * temperature)

```

```{r average_Cant}

Cant_model_average <- Cant %>% 
  mutate(Cant_pos = if_else(Cant < 0, 0, Cant)) %>% 
  group_by(lon, lat, depth, eras, basin) %>% 
  summarise(Cant_mean = mean(Cant),
            Cant_sd = sd(Cant),
            Cant_pos_mean = mean(Cant_pos),
            Cant_pos_sd = sd(Cant_pos),
            gamma_mean = mean(gamma)) %>% 
  ungroup()

Cant_model_average_zonal <- Cant_model_average %>% 
  group_by(lat, depth, eras, basin) %>% 
  summarise(Cant_mean_sd = sd(Cant_mean, na.rm = TRUE),
            Cant_mean = mean(Cant_mean, na.rm = TRUE),
            Cant_sd_mean = mean(Cant_sd, na.rm = TRUE),
            Cant_pos_mean_sd = sd(Cant_pos_mean, na.rm = TRUE),
            Cant_pos_mean = mean(Cant_pos_mean, na.rm = TRUE),
            Cant_pos_sd_mean = mean(Cant_pos_sd, na.rm = TRUE),
            gamma_mean = mean(gamma_mean)) %>% 
  ungroup()

```


# Neutral density section

## Mean values

The mean zonal distribution of neutral densities was calculated. CAVEAT: The binning here does not reflect the isoneutral density slabs used for MLR fitting.

```{r gamma_sections_mean}

Cant_model_average_zonal %>% 
  filter(depth <= 4500,
         lat > -60) %>% 
  ggplot(aes(lat, depth, z = gamma_mean)) +
  geom_contour_filled(binwidth = 0.25) +
  scale_fill_viridis_d(name = "Gamma",
                       direction = -1) +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```

# Cant sections

## Mean values

```{r Cant_sections_mean}

Cant_model_average_zonal %>% 
  filter(depth <= 4500,
         lat > -60) %>% 
  ggplot(aes(lat, depth, z = Cant_mean)) +
  geom_contour_fill(breaks = MakeBreaks(5),
                    na.fill = TRUE) +
  scale_fill_divergent(guide = "colorstrip",
                       breaks = MakeBreaks(5),
                       name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```

## Mean zonal standard deviation across MLR models

Standard deviation across Cant from all MLR models was calculate for each grid cell (XYZ). The zonal mean of this standard deviation should reflect the uncertainty associated to the predictor selection within each slab and era. 

```{r Cant_sections_sd_models}

Cant_model_average_zonal %>% 
  filter(depth <= 4500,
         lat > -60) %>% 
  ggplot(aes(lat, depth, z = Cant_sd_mean)) +
  geom_contour_filled() +
  scale_fill_viridis_d(name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```

## Zonal standard deviation of mean Cant estimates

Standard deviation of mean Cant values was calculate across all longitudes. This standard deviation should reflect the zonal variability of Cant within the basin and era.

```{r Cant_sections_sd_Cant}

Cant_model_average_zonal %>% 
  filter(depth <= 4500,
         lat > -60) %>% 
  ggplot(aes(lat, depth, z = Cant_mean_sd)) +
  geom_contour_filled() +
  scale_fill_viridis_d(name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```


## Mean positive values

```{r Cant_sections_positive_mean}

Cant_model_average_zonal %>% 
  filter(depth <= 4500,
         lat > -60) %>% 
  ggplot(aes(lat, depth, z = Cant_pos_mean)) +
  geom_contour_filled() +
  scale_fill_viridis_d(name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```

# Cant maps

## Depth layers

```{r Cant_depth_layer_maps, fig.asp=1}

mapWorld <- borders("world", colour = "gray60", fill = "gray60")

Cant_model_average %>%
  filter(depth %in% c(150, 500, 1000, 3000)) %>% 
  ggplot(aes(lon, lat, fill = Cant_mean)) + 
  mapWorld +
  geom_raster() +
  scale_fill_divergent(guide = "colorstrip",
                       breaks = MakeBreaks(5),
                       name = "Cant") +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  coord_quickmap(expand = 0) +
  facet_grid(depth~eras)

```

## Inventory calculation

To calculate Cant column inventories, we:  

1. Multiple layer thickness with Cant concentration to get a layer inventory
2. Sum positive Cant layer inventories from 150 - 3000 m 

```{r calculate_layer_thickness}

depth_level_volume <- tibble(
  depth = unique(Cant_model_average_zonal$depth))

depth_level_volume <- depth_level_volume %>% 
  mutate(layer_thickness_above = replace_na((depth - lag(depth)) / 2, 0),
         layer_thickness_below = replace_na((lead(depth) - depth) / 2, 0),
         layer_thickness = layer_thickness_above + layer_thickness_below) %>% 
  select(-c(layer_thickness_above,
         layer_thickness_below))

Cant_model_average <- full_join(Cant_model_average, depth_level_volume)

rm(depth_level_volume)

```

```{r calculate_inventories}

Cant_model_average <- Cant_model_average %>% 
  mutate(Cant_layer = Cant_mean * layer_thickness)

Cant_inventory <- Cant_model_average %>% 
  filter(depth <= 3000) %>% 
  mutate(Cant_pos_layer = if_else(Cant_layer < 0, 0, Cant_layer)) %>% 
  group_by(lon, lat, basin, eras) %>% 
  summarise(Cant_pos_inventory = sum(Cant_pos_layer, na.rm = TRUE) / 1000,
            Cant_inventory = sum(Cant_layer, na.rm = TRUE) / 1000) %>% 
  ungroup()

```


## Inventories

### All Cant estimates

```{r Cant_inventory_map, fig.asp=1}

Cant_inventory %>% 
  ggplot(aes(lon, lat, fill = Cant_inventory)) + 
  mapWorld +
  geom_raster() +
  scale_fill_divergent(guide = "colorstrip",
                       breaks = MakeBreaks(5),
                       name = "Cant") +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  coord_quickmap(expand = 0) +
  facet_wrap(~eras, ncol = 1)

```


### Positive Cant estimates

```{r Cant_pos_inventory_map, fig.asp=1}

Cant_inventory %>% 
  ggplot(aes(lon, lat, fill = Cant_pos_inventory)) + 
  mapWorld +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_quickmap(expand = 0) +
  facet_wrap(~eras, ncol = 1)

```



# Neutral density calculation

```{r calculate_neutral_density_test, fig.asp=0.5, eval=FALSE}

GLODAP <- read_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
                                "GLODAP_MLR_fitting_ready.csv"))

cruises_meridional <- c("1041")

GLODAP_cruise <- GLODAP %>% 
  filter(cruise %in% cruises_meridional)


GLODAP_cruise <- GLODAP_cruise %>% 
  mutate(gamma_calc = swRho(salinity = salinity,
                            temperature = temperature,
                            pressure = depth,
                            longitude = lon,
                            latitude = lat,
                            eos = "gsw"))


GLODAP_cruise <- GLODAP_cruise %>% 
  mutate(gamma_calc = gamma_calc - 1000,
         delta_gamma = gamma - gamma_calc)


lat_section <- 
GLODAP_cruise %>%
  ggplot(aes(lat, depth)) +
  scale_y_reverse() +
  scale_color_viridis_c() +
  theme(legend.position = "bottom")

lat_section +
  geom_point(aes(col = gamma))

lat_section +
  geom_point(aes(col = gamma_calc))

lat_section +
  geom_point(aes(col = delta_gamma))

```

