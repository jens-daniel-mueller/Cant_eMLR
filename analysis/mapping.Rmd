---
title: "Mapping"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r library, message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(oce)
library(marelac)
library(metR)
library(reticulate)

```

```{r read_parameters, include = FALSE}

parameters <-
  read_rds(here::here("data",
                       "parameters.rds"))
```

```{r read_mask_files}

basinmask <- read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                                 "basin_mask_WOA18.csv"))

landmask <- read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                                 "land_mask_WOA18.csv"))

```

```{r read_parameters_functions, include = FALSE}
source(here::here("code", "plotting_functions.R"))
```

```{r ggplot_theme, include = FALSE}
theme_set(theme_bw())
```

# Required data

All required data sets were subsetted spatially in the read-in section *Data base*.
Currently, following data sets are used for mapping:

## GLODAPv2_2016b_MappedClimatologies

Following variables are currently used:  

- Salinity
- Temperature
- Phosphate (+Phosphate*)
- Silicate
- Oxygen (+AOU)


```{r load_GLODAPv2_2016b_MappedClimatologies}

variables <-
  c("salinity", "temperature", "oxygen", "PO4", "silicate")

for (i_variable in variables) {
  temp <- read_csv(
    here::here(
      "data/GLODAPv2_2016b_MappedClimatologies/_summarized_files",
      paste(i_variable, ".csv", sep = "")
    )
  )
  
  if (exists("GLODAP_predictors")) {
    GLODAP_predictors <- full_join(GLODAP_predictors, temp)
  }
  
  if (!exists("GLODAP_predictors")) {
    GLODAP_predictors <- temp
  }
}

rm(temp, i_variable, variables)

# removed na's attributable to slightly different coverage of predictor fields
GLODAP_predictors <- GLODAP_predictors %>%
  drop_na()

GLODAP_predictors <- GLODAP_predictors %>%
  rename(sal = salinity,
         tem = temperature)
```


## World Ocean Atlas 2018

- Neutral density
- Basin mask


```{r load_WOA18, eval=FALSE}

WOA18_predictors <-
  read_csv(
    here::here(
      "data/World_Ocean_Atlas_2018/_summarized_files",
      "WOA18_predictors.csv"
    )
  )

```

## eMLR models

```{r load_eMLR_coeffcients}

all_lm <- read_csv(here::here("data/eMLR",
                              "all_lm.csv"))

```

## WOA13

Neutral densities and the basin mask based on WOA13 and provided by Dominic Clement are currently not used.

```{r load_WOA13_gamma}

WOA13 <-
  read_csv(
    here::here(
      "data/World_Ocean_Atlas_2013_Clement/_summarized_files",
      "WOA13_mask_gamma.csv"
    )
  )

WOA13_gamma <- WOA13 %>%
  select(-mask)

rm(WOA13)

```


# Join predictor climatologies

**CAVEAT**: Coverage of GLODAP climatologies differs slightly for parameters (some are NA in some regions)

## Control plots

Maps of number of observations per horizontal grid cell, which reflects the number of depth levels.

### GLODAP climatology

```{r control_plots_pre_merging_GLODAP, fig.asp=0.6}

GLODAP_n <- GLODAP_predictors %>% 
  drop_na() %>% 
  group_by(lat, lon) %>% 
  summarise(n = n()) %>% 
  ungroup()

GLODAP_n %>%
  ggplot(aes(lon, lat, fill = n)) +
  geom_raster() +
  scale_fill_viridis_c(direction = -1) +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom")

rm(GLODAP_n)

```

### WOA18 climatology

```{r control_plots_pre_merging_WOA18, fig.asp=0.6, eval=FALSE}

WOA18_predictors_n <- WOA18_predictors %>% 
  drop_na() %>% 
  group_by(lat, lon) %>% 
  summarise(n = n()) %>% 
  ungroup()

WOA18_predictors_n %>%
  ggplot(aes(lon, lat, fill = n)) +
  geom_raster() +
  scale_fill_viridis_c(direction = -1) +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom")

rm(WOA18_predictors_n)

```



### Neutral density zonal mean section

```{r WOA18_gamma_mean_sections, eval=FALSE}

WOA18_predictors_zonal <- WOA18_predictors %>%
  group_by(lat, depth, basin) %>%
  summarise(gamma_mean = mean(gamma)) %>%
  ungroup()

WOA18_predictors_zonal_Atl <- WOA18_predictors_zonal %>%
  filter(basin == "Atlantic") %>%
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Atl))

WOA18_predictors_zonal_Ind_Pac <- WOA18_predictors_zonal %>%
  filter(basin == "Indo-Pacific") %>%
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Ind_Pac))

WOA18_predictors_zonal <- bind_rows(WOA18_predictors_zonal_Atl, WOA18_predictors_zonal_Ind_Pac)

rm(WOA18_predictors_zonal_Atl, WOA18_predictors_zonal_Ind_Pac)

slab_breaks <- c(parameters$slabs_Atl[1:12], Inf)

WOA18_predictors_zonal %>%
  filter(depth <= parameters$inventory_depth) %>%
  ggplot(aes(lat, depth, z = gamma_mean)) +
  geom_contour_filled(breaks = slab_breaks) +
  geom_contour(breaks = slab_breaks,
               col = "white") +
  geom_text_contour(breaks = slab_breaks,
                    col = "white",
                    skip = 1) +
  scale_fill_viridis_d(name = "Gamma",
                       direction = -1) +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin ~ .)

rm(WOA18_predictors_zonal, slab_breaks)

```



## WOA18 + GLODAP

WOA18 and GLODAP predictor climatologies are merged. Only horizontal grid cells with observations from both predictor fields are kept.

```{r join_WOA18_GLODAP_predictors, fig.asp=0.5, eval=FALSE}

GLODAP_depths <- unique(GLODAP_predictors$depth)

predictors <- full_join(GLODAP_predictors, WOA18_predictors)
rm(GLODAP_predictors, WOA18_predictors)

predictors <- predictors %>% 
  group_by(lat, lon) %>% 
  mutate(n_PO4 = sum(!is.na(PO4)),
         n_sal = sum(!is.na(sal))) %>% 
  ungroup()

predictors <- predictors %>% 
  filter(n_PO4 > 1,
         n_sal > 1) %>% 
  select(-c(n_PO4 , n_sal))

```

```{r interpolate_WOA18_vertically, eval=FALSE}

predictors <- predictors %>% 
  group_by(lat, lon) %>% 
  arrange(depth) %>% 
  mutate(tem =   approxfun(depth, tem,   rule = 2)(depth),
         sal =   approxfun(depth, sal,   rule = 2)(depth),
         gamma = approxfun(depth, gamma, rule = 2)(depth)) %>% 
  ungroup()

predictors <- predictors %>% 
  filter(depth %in% GLODAP_depths)

rm(GLODAP_depths)

```

### Spatial boundaries

Only observations were taken into consideration with:

- minimum sampling depth:  `r parameters$depth_min`m
- minimum bottom depth:  `r parameters$bottomdepth_min`m
- maximum latitude:  `r parameters$lat_max`°N


```{r apply_spatial_boundaries, eval=FALSE}

predictors <- predictors %>% 
  filter(depth >= parameters$depth_min)

predictors <- predictors %>% 
  filter(lat <= parameters$lat_max)

predictors_grid <- predictors %>% 
  group_by(lat, lon) %>% 
  summarise(bottomdepth = max(depth)) %>% 
  ungroup()

predictors <- full_join(predictors, predictors_grid)

predictors <- predictors %>% 
  filter(bottomdepth >= parameters$bottomdepth_min) %>% 
  select(-bottomdepth)

```



### Control plots

#### Maps

Three maps are generated to control successful merging of data sets.

```{r joined_climatology_control_PO4, eval=FALSE}
map_climatology(predictors, "PO4")
```


```{r joined_climatology_control_tem, eval=FALSE}
map_climatology(predictors, "tem")
```


```{r WOA18_GLODAP_climatology_control_plots, fig.asp=0.6, eval=FALSE}

predictors %>%
  ggplot(aes(lon, lat)) +
  geom_bin2d(binwidth = c(1,1)) +
  scale_fill_viridis_c(direction = -1) +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom")

```


#### Predictor profiles

Likewise, predictor profiles for the North Atlantic are plotted to control successful merging of the data sets.

```{r predictor_profiles_N_Atl, fig.asp=1.5, eval=FALSE}

N_Atl <- predictors %>% 
  filter(lat == parameters$lat_Atl_profile,
         lon == parameters$lon_Atl_section)

N_Atl <- N_Atl %>% 
  select(-basin) %>% 
  pivot_longer(oxygen:gamma, names_to = "parameter", values_to = "value")

N_Atl %>% 
  ggplot(aes(value, depth)) +
  geom_path() +
  geom_point() +
  scale_y_reverse() +
  facet_wrap(~parameter,
             scales = "free_x",
             ncol = 2)

rm(N_Atl)

```

#### Neutral density zonal mean section

```{r predictors_gamma_mean_sections, eval=FALSE}

predictors_zonal <- predictors %>%
  group_by(lat, depth, basin) %>%
  summarise(gamma_mean = mean(gamma)) %>%
  ungroup()

predictors_zonal_Atl <- predictors_zonal %>%
  filter(basin == "Atlantic") %>%
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Atl))

predictors_zonal_Ind_Pac <- predictors_zonal %>%
  filter(basin == "Indo-Pacific") %>%
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Ind_Pac))

predictors_zonal <- bind_rows(predictors_zonal_Atl, predictors_zonal_Ind_Pac)

rm(predictors_zonal_Atl, predictors_zonal_Ind_Pac)

slab_breaks <- c(parameters$slabs_Atl[1:12], Inf)

predictors_zonal %>%
  filter(depth <= parameters$inventory_depth) %>%
  ggplot(aes(lat, depth, z = gamma_mean)) +
  geom_contour_filled(breaks = slab_breaks) +
  geom_contour(breaks = slab_breaks,
               col = "white") +
  geom_text_contour(breaks = slab_breaks,
                    col = "white",
                    skip = 1) +
  scale_fill_viridis_d(name = "Gamma",
                       direction = -1) +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin ~ .)

rm(predictors_zonal, slab_breaks)

```



## WOA13 + GLODAP

Currently not used.

```{r join_WOA13_GLODAP_predictors}

predictors <- full_join(GLODAP_predictors, WOA13_gamma)
GLODAP_depths <- unique(GLODAP_predictors$depth)

rm(GLODAP_predictors, WOA13_gamma)

predictors <- predictors %>% 
  group_by(lat, lon) %>% 
  mutate(n_oxygen = sum(!is.na(oxygen)),
         n_PO4 = sum(!is.na(PO4)),
         n_silicate = sum(!is.na(silicate)),
         n_sal = sum(!is.na(sal)),
         n_tem = sum(!is.na(tem)),
         n_gamma = sum(!is.na(gamma))) %>% 
  ungroup()

predictors <- predictors %>% 
  filter(n_oxygen > 0,
         n_PO4 > 0,
         n_silicate > 0, 
         n_sal > 0, 
         n_tem > 0, 
         n_gamma > 0) %>% 
  select(-c(n_oxygen, 
            n_PO4, 
            n_silicate, 
            n_sal, 
            n_tem,
            n_gamma))

predictors <- predictors %>% 
  drop_na()

```


# Prepare predictor fields

## PO~4~*

### Calculation 

Currently, the predictor PO~4~* is calculated according to Clement and Gruber (2018), ie based on oxygen rather than nitrate.

```{r calculate_phosphate_star_clement}

predictors <- predictors %>% 
  rename(phosphate = PO4) %>% 
  mutate(phosphate_star = phosphate + (oxygen / 170)  - 1.95)

```

### Maps

```{r PO4_star_climatology_maps, fig.asp=0.6}

map_climatology(predictors, "phosphate_star")

```

### Sections

```{r PO4_star_climatology_section, fig.asp=0.6}

section_climatology(predictors, "phosphate_star")

```


## AOU

### Calculation

AOU was calculated as the difference between saturation concentration and observed concentration.  

**CAVEAT**: Algorithms used to calculate oxygen saturation concentration are not yet identical in GLODAP data set (fitting) and predictor climatologies (mapping).

```{r calculate_aou_climatology}

predictors <- predictors %>% 
  mutate(oxygen_sat = gas_satconc(S = sal,
                                  t = tem,
                                  P = 1.013253,
                                  species = "O2"),
         aou = oxygen_sat - oxygen) %>% 
  select(-oxygen_sat)


```

### Maps

```{r aou_climatology_maps, fig.asp=0.6}

map_climatology(predictors, "aou")

```

### Sections

```{r aou_climatology_section, fig.asp=0.6}

section_climatology(predictors, "aou")

```

## Isoneutral slabs

The following boundaries for isoneutral slabs were defined:

- Atlantic: `r parameters$slabs_Atl`
- Indo-Pacific: `r parameters$slabs_Ind_Pac`

Continuous neutral density (gamma) values based on WOA13 are grouped into isoneutral slabs.

```{r cut_isoneutral_slabs}

predictors_Atl <- predictors %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma, parameters$slabs_Atl))

predictors_Ind_Pac <- predictors %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma, parameters$slabs_Ind_Pac))

predictors <- bind_rows(predictors_Atl, predictors_Ind_Pac)

rm(predictors_Atl, predictors_Ind_Pac)

```


# Prepare model coefficients

```{r prepare_model_coefficients}

all_lm <- all_lm %>% 
  select(term, estimate, basin, era, eras, gamma_slab, model)

all_lm <- all_lm %>% 
  mutate(estimate = if_else(is.na(estimate), 0, estimate))

all_lm_wide <- all_lm %>% 
  pivot_wider(names_from = era, values_from = estimate,
              names_prefix = "coeff_")

all_lm_wide <- all_lm_wide %>% 
  mutate(JGOFS_GO = coeff_GO_SHIP - coeff_JGOFS_WOCE,
         GO_new = coeff_new_era - coeff_GO_SHIP) %>% 
  select(-c(coeff_JGOFS_WOCE,
            coeff_GO_SHIP,
            coeff_new_era))

all_lm_long <- all_lm_wide %>% 
  pivot_longer(JGOFS_GO:GO_new, names_to = "eras_fit", values_to = "delta_coeff")

all_lm_long <- all_lm_long %>% 
  filter(eras == eras_fit) %>% 
  select(-eras_fit)

all_lm_wide <- all_lm_long %>% 
  pivot_wider(values_from = delta_coeff,
              names_from = term,
              names_prefix = "delta_coeff_",
              values_fill = 0)

rm(all_lm_long, all_lm)

```

## Merge MLRs + climatology

```{r merge_model_coeff_predictor_climatology}

Cant <- full_join(predictors, all_lm_wide)
rm(predictors, all_lm_wide)

```

# Map Cant

## Apply MLRs to predictor

```{r calculate_Cant}

Cant <- Cant %>% 
  mutate(Cant = `delta_coeff_(Intercept)` +
           delta_coeff_aou * aou +
           delta_coeff_oxygen * oxygen +
           delta_coeff_phosphate * phosphate +
           delta_coeff_phosphate_star * phosphate_star +
           delta_coeff_silicate * silicate +
           delta_coeff_sal * sal + 
           delta_coeff_tem * tem)

```

## Mean Cant fields

Mean and sd are calculated for Cant in each grid cell (XYZ), basin and era combination. Calculations are performed for all Cant values vs positive values only. This averaging step summarizes the information derived from ten best fitting MLRs. 

```{r Calculate_Cant_mean}

Cant <- Cant %>%
  select(lon, lat, depth, eras, basin, Cant, gamma)

# Cant_model_average <- Cant %>%
#   mutate(Cant_pos = if_else(Cant < 0, 0, Cant)) %>%
#   group_by(lon, lat, depth, eras, basin) %>%
#   summarise(across(c("Cant", "Cant_pos", "gamma"),
#                    list(
#                      mean = ~ mean(.x, na.rm = TRUE),
#                      sd = ~ sd(.x, na.rm = TRUE)
#                    ))) %>%
#   ungroup()

Cant_model_average <- Cant %>%
  mutate(Cant_pos = if_else(Cant < 0, 0, Cant)) %>%
  group_by(lon, lat, depth, eras, basin) %>%
  summarise(Cant_mean = mean(Cant, na.rm = TRUE),
            Cant_sd = sd(Cant, na.rm = TRUE),
            Cant_pos_mean = mean(Cant_pos, na.rm = TRUE),
            Cant_pos_sd = sd(Cant_pos, na.rm = TRUE),
            gamma_mean = mean(gamma, na.rm = TRUE),
            gamma_sd = sd(gamma, na.rm = TRUE)) %>%
  ungroup()

Cant_model_average_Atl <- Cant_model_average %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Atl))

Cant_model_average_Ind_Pac <- Cant_model_average %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma_mean, parameters$slabs_Ind_Pac))

Cant_model_average <- bind_rows(Cant_model_average_Atl, Cant_model_average_Ind_Pac)

rm(Cant_model_average_Atl, Cant_model_average_Ind_Pac)

```

## Mean Cant sections

For each basin and era combination, the zonal mean Cant is calculated, again for all vs positive only values. Likewise, sd is calculated for the averaging of the mean basin fields.

```{r Calculate_Cant_mean_sections}

Cant_model_average_zonal <- Cant_model_average %>%
  group_by(lat, depth, eras, basin) %>%
  summarise(across(
    c(
      "Cant_mean",
      "Cant_pos_mean",
      "Cant_sd",
      "Cant_pos_sd",
      "gamma_mean",
      "gamma_sd"
    ),
    list(mean = ~ mean(.x, na.rm = TRUE),
         sd = ~ sd(.x, na.rm = TRUE))
  )) %>%
  ungroup()


# Cant_model_average_zonal <- Cant_model_average %>% 
#   group_by(lat, depth, eras, basin) %>% 
#   summarise(Cant_mean_sd = sd(Cant_mean, na.rm = TRUE),
#             Cant_mean = mean(Cant_mean, na.rm = TRUE),
#             Cant_sd_mean = mean(Cant_sd, na.rm = TRUE),
#             Cant_pos_mean_sd = sd(Cant_pos_mean, na.rm = TRUE),
#             Cant_pos_mean = mean(Cant_pos_mean, na.rm = TRUE),
#             Cant_pos_sd_mean = mean(Cant_pos_sd, na.rm = TRUE),
#             gamma_mean = mean(gamma_mean)) %>% 
#   ungroup()


Cant_model_average_zonal_Atl <- Cant_model_average_zonal %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma_mean_mean, parameters$slabs_Atl))

Cant_model_average_zonal_Ind_Pac <- Cant_model_average_zonal %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma_mean_mean, parameters$slabs_Ind_Pac))

Cant_model_average_zonal <- bind_rows(Cant_model_average_zonal_Atl, Cant_model_average_zonal_Ind_Pac)

rm(Cant_model_average_zonal_Atl, Cant_model_average_zonal_Ind_Pac)

```


# Neutral density section

## Mean values

The mean zonal distribution of neutral densities was calculated. **CAVEAT:** Binning here does not include two highest isoneutral density slabs in the Atlantic, yet.

```{r gamma_sections_mean}

slab_breaks <- c(parameters$slabs_Atl[1:12],Inf)

Cant_model_average_zonal %>% 
  filter(depth <= parameters$inventory_depth) %>% 
  ggplot(aes(lat, depth, z = gamma_mean_mean)) +
  geom_contour_filled(breaks = slab_breaks) +
  geom_contour(breaks = slab_breaks,
               col = "white") +
  geom_text_contour(breaks = slab_breaks,
               col = "white",
               skip = 1) +
  scale_fill_viridis_d(name = "Gamma",
                       direction = -1) +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```

# Cant sections

## Mean values

```{r Cant_sections_mean}

Cant_model_average_zonal %>%
  filter(depth <= parameters$inventory_depth) %>%
  ggplot(aes(lat, depth, z = Cant_mean_mean)) +
  geom_contour_fill(breaks = MakeBreaks(5),
                    na.fill = TRUE) +
  scale_fill_divergent(guide = "colorstrip",
                       breaks = MakeBreaks(5),
                       name = "Cant") +
  geom_contour(aes(lat, depth, z = gamma_mean_mean),
               breaks = slab_breaks,
               col = "black") +
  geom_text_contour(
    aes(lat, depth, z = gamma_mean_mean),
    breaks = slab_breaks,
    col = "black",
    skip = 1
  ) +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin ~ eras)

```

## Mean zonal standard deviation across MLR models

Standard deviation across Cant from all MLR models was calculate for each grid cell (XYZ). The zonal mean of this standard deviation should reflect the uncertainty associated to the predictor selection within each slab and era. 

```{r Cant_sections_sd_models}

Cant_model_average_zonal %>%
  filter(depth <= parameters$inventory_depth) %>%
  ggplot(aes(lat, depth, z = Cant_sd_mean)) +
  geom_contour_filled() +
  geom_contour(aes(lat, depth, z = gamma_mean_mean),
               breaks = slab_breaks,
               col = "white") +
  geom_text_contour(
    aes(lat, depth, z = gamma_mean_mean),
    breaks = slab_breaks,
    col = "white",
    skip = 1
  ) +
  scale_fill_viridis_d(name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin ~ eras)

```

## Zonal standard deviation of mean Cant estimates

Standard deviation of mean Cant values was calculate across all longitudes. This standard deviation should reflect the zonal variability of Cant within the basin and era.

```{r Cant_sections_sd_Cant}

Cant_model_average_zonal %>% 
  filter(depth <= parameters$inventory_depth) %>% 
  ggplot(aes(lat, depth, z = Cant_mean_sd)) +
  geom_contour_filled() +
  geom_contour(aes(lat, depth, z = gamma_mean_mean),
               breaks = slab_breaks,
               col = "white") +
  geom_text_contour(
    aes(lat, depth, z = gamma_mean_mean),
    breaks = slab_breaks,
    col = "white",
    skip = 1
  ) +
  scale_fill_viridis_d(name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```


## Mean positive values

```{r Cant_sections_positive_mean}

Cant_model_average_zonal %>% 
  filter(depth <= parameters$inventory_depth) %>% 
  ggplot(aes(lat, depth, z = Cant_pos_mean_mean)) +
  geom_contour_filled() +
  geom_contour(aes(lat, depth, z = gamma_mean_mean),
               breaks = slab_breaks,
               col = "white") +
  geom_text_contour(
    aes(lat, depth, z = gamma_mean_mean),
    breaks = slab_breaks,
    col = "white",
    skip = 1
  ) +
  scale_fill_viridis_d(name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```

## Sections

### JGOFS_GO

```{r Cant_sections_positive_mean_one_lon_JGOFS_GO}

section_climatology(Cant_model_average %>% filter(eras == "JGOFS_GO"),
                    "Cant_mean")

```

### GO_new

```{r Cant_sections_positive_mean_one_lon_GO_new}

section_climatology(Cant_model_average %>% filter(eras == "GO_new"),
                    "Cant_mean")

```


# Cant maps

## Depth layers

Cant concentration for selected depth levels at which mapping was performed.

```{r Cant_depth_layer_maps, fig.asp=1}

Cant_model_average %>%
  filter(depth %in% c(150, 500, 1000, 3000)) %>% 
  ggplot(aes(lon, lat, fill = Cant_mean)) + 
  geom_raster() +
  scale_fill_divergent(guide = "colorstrip",
                       breaks = MakeBreaks(5),
                       name = "Cant") +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  coord_quickmap(expand = 0) +
  facet_grid(depth~eras)

```

## Inventory calculation

To calculate Cant column inventories, we:  

1. Multiple layer thickness with Cant concentration to get a layer inventory
2. For each horizontal grid cell and era, sum Cant layer inventories from 150 - 3000 m

Step 2 is performed again for all Cant and positive Cant values only

```{r calculate_inventories}

depth_level_volume <- tibble(depth = unique(Cant_model_average$depth))

depth_level_volume <- depth_level_volume %>%
  mutate(
    layer_thickness_above = replace_na((depth - lag(depth)) / 2, 0),
    layer_thickness_below = replace_na((lead(depth) - depth) / 2, 0),
    layer_thickness = layer_thickness_above + layer_thickness_below
  ) %>%
  select(-c(layer_thickness_above,
            layer_thickness_below))

Cant_model_average <-
  full_join(Cant_model_average, depth_level_volume)

Cant_model_average <- Cant_model_average %>%
  mutate(layer_inv = Cant_mean * layer_thickness) %>%
  mutate(layer_inv_pos = if_else(layer_inv < 0, 0, layer_inv)) %>%
  select(-layer_thickness)

Cant_inv <- Cant_model_average %>%
  filter(depth <= parameters$inventory_depth) %>%
  group_by(lon, lat, basin, eras) %>%
  summarise(
    cant_inv_pos = sum(layer_inv_pos, na.rm = TRUE) / 1000,
    cant_inv     = sum(layer_inv, na.rm = TRUE) / 1000
  ) %>%
  ungroup()


```


## Inventories

### All Cant estimates

```{r Cant_inventory_map, fig.asp=1}

library(scales)

Cant_inv %>% 
  ggplot() +
    geom_raster(data = landmask %>% filter(region == "land"),
                aes(lon, lat), fill = "grey80") +
    geom_raster(aes(lon, lat, fill = cant_inv)) +
    coord_quickmap(expand = 0) +
    scale_fill_gradient2(high = muted("red"),
                         mid = "white",
                         low = muted("blue"),
                         midpoint = 0,
                         space = "Lab",
                         na.value = "green") +
  facet_wrap(~eras, ncol = 1) +
    theme(
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank()
    )

```


### Positive Cant estimates

```{r Cant_pos_inventory_map, fig.asp=1}

Cant_inv %>% 
  ggplot() +
    geom_raster(data = landmask %>% filter(region == "land"),
                aes(lon, lat), fill = "grey80") +
    geom_raster(aes(lon, lat, fill = cant_inv_pos)) +
    coord_quickmap(expand = 0) +
    scale_fill_viridis_c() +
  facet_wrap(~eras, ncol = 1) +
    theme(
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank()
    )

```

# Write csv

```{r write_cant_inventory}

Cant_model_average %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_2020.csv"))

Cant_inv %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_inv_2020.csv"))

```


# Open tasks

- Check PO4* calculation
- Harmonize AOU calculation in fitting and mapping
- Plot Cant sections for individual MLR models

# Open questions

- 
