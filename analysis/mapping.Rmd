---
title: "Mapping"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r library, message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(oce)
library(marelac)
library(metR)
library(reticulate)

```


```{r read_parameters, include = FALSE}
parameters <-
  read_rds(here::here("data",
                       "parameters.rds"))
```


```{r read_mask_files}

basinmask <- read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                                 "basin_mask_WOA18.csv"))

landmask <- read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                                 "land_mask_WOA18.csv"))

```


```{r read_parameters_functions, include = FALSE}
source(here::here("code", "plotting_functions.R"))
```

```{r ggplot_theme, include = FALSE}
theme_set(theme_bw())
```

# Required data

Currently, following data sets are used for mapping: 

- GLODAPv2_2016b_MappedClimatologies
  - Salinity
  - Temperature
  - Phosphate (+Phosphate*)
  - Silicate
  - Oxygen (+AOU)
- World Ocean Atlas 2013
  - Neutral densities calculated by D Clement
- World Ocean Atlas 2018
  - Basin mask
- eMLR model coefficients

Aim is to use WOA18 neutral density instead of WOA13, but calculation still need to be implemented.


```{r load_GLODAPv2_2016b_MappedClimatologies}

variables <- c("salinity", "temperature", "oxygen", "PO4", "silicate")

for (i_variable in variables) {
  
  # i_variable <- variables[2]
  # print(i_variable)
  
  temp <- read_csv(
    here::here("data/GLODAPv2_2016b_MappedClimatologies/_summarized_files",
               paste(i_variable,".csv", sep = "")))
  
  if (exists("GLODAP_predictors")) {
     GLODAP_predictors <- full_join(GLODAP_predictors, temp)
  }
  
  if (!exists("GLODAP_predictors")) {
    GLODAP_predictors <- temp
  }

}

rm(temp, i_variable, variables)
#min(GLODAP_predictors$lon)

GLODAP_predictors <- GLODAP_predictors %>% 
  rename(sal = salinity,
         tem = temperature)

```

```{r load_WOA18}

WOA18_predictors <-
  read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                       "WOA18_predictors.csv"))

WOA18_predictors <- WOA18_predictors %>% 
  rename(salinity = sal, temperature = tem)
#min(WOA18_predictors$lon)

```

```{r load_WOA13_gamma}

WOA13 <-
  read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                       "WOA13_mask_gamma.csv"))

WOA13_gamma <- WOA13 %>% 
  select(-mask)

WOA13_gamma <- WOA13_gamma %>% 
  rename(lat = latitude, lon = longitude) %>% 
  mutate(lon = if_else(lon < 20, lon + 360, lon))

rm(WOA13)
# min(WOA13_gamma$lon)

```


```{r load_eMLR_coeffcients}

all_lm <- read_csv(here::here("data/eMLR",
                              "all_lm.csv"))

```


# Join predictor climatologies

**CAVEAT**: Coverage of GLODAP climatologies differs slightly for parameters (some are NA in some regions)

## Control plots

Maps of number of observations per horizontal grid cell.

### GLODAP climatology

```{r control_plots_pre_merging_GLODAP, fig.asp=0.6}

GLODAP_n <- GLODAP_predictors %>% 
  drop_na() %>% 
  group_by(lat, lon) %>% 
  summarise(n = n()) %>% 
  ungroup()

GLODAP_n %>%
  ggplot(aes(lon, lat, fill = n)) +
  geom_raster() +
  scale_fill_viridis_c(direction = -1) +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom")

rm(GLODAP_n)

```

### WOA13 climatology

```{r control_plots_pre_merging_WOA13, fig.asp=0.6}

WOA13_gamma_n <- WOA13_gamma %>% 
  drop_na() %>% 
  group_by(lat, lon) %>% 
  summarise(n = n()) %>% 
  ungroup()

WOA13_gamma_n %>%
  ggplot(aes(lon, lat, fill = n)) +
  geom_raster() +
  scale_fill_viridis_c(direction = -1) +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom")

rm(WOA13_gamma_n)

```


## WOA13 + GLODAP

Predictor climatologies are merged. Only horizontal grid cells with at least one observation are kept. Rows with NA values are removed.

```{r join_WOA13_GLODAP_predictors}

predictors <- full_join(GLODAP_predictors, WOA13_gamma)
GLODAP_depths <- unique(GLODAP_predictors$depth)

rm(GLODAP_predictors, WOA13_gamma)

predictors <- predictors %>% 
  group_by(lat, lon) %>% 
  mutate(n_oxygen = sum(!is.na(oxygen)),
         n_PO4 = sum(!is.na(PO4)),
         n_silicate = sum(!is.na(silicate)),
         n_sal = sum(!is.na(sal)),
         n_tem = sum(!is.na(tem)),
         n_gamma = sum(!is.na(gamma))) %>% 
  ungroup()

predictors <- predictors %>% 
  filter(n_oxygen > 0,
         n_PO4 > 0,
         n_silicate > 0, 
         n_sal > 0, 
         n_tem > 0, 
         n_gamma > 0) %>% 
  select(-c(n_oxygen, 
            n_PO4, 
            n_silicate, 
            n_sal, 
            n_tem,
            n_gamma))

predictors <- predictors %>% 
  drop_na()

```

### Spatial boundaries

Only mapped variables were taken into consideration which fullfill the same criteria applied to observational data before MLR fitting:

- minimum sampling depth:  `r parameters$depth_min`m
- minimum bottom depth:  `r parameters$bottomdepth_min`m
- maximum latitude:  `r parameters$lat_max`°N



```{r apply_spatial_boundaries}

predictors <- predictors %>% 
  filter(depth >= parameters$depth_min)

predictors <- predictors %>% 
  filter(lat <= parameters$lat_max)

predictors <- predictors %>% 
  group_by(lat, lon) %>% 
  mutate(bottomdepth = max(depth)) %>% 
  ungroup()

predictors <- predictors %>% 
  filter(bottomdepth >= parameters$bottomdepth_min) %>% 
  select(-bottomdepth)

```

### Basin mask

Please note that some predictor variables are available outside the WOA18 basin mask, but will be removed for further analysis.

```{r join_basin_mask}

predictors <- inner_join(predictors, basinmask)
rm(basinmask)

```

### Maps

Three maps are generated to control succesful merging of data sets.

```{r WOA13_GLODAP_climatology_control_plots, fig.asp=0.6}

predictors %>%
  ggplot(aes(lon, lat)) +
  geom_bin2d(binwidth = c(1,1)) +
  scale_fill_viridis_c(direction = -1) +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom")

predictors %>%
  filter(depth == 150) %>% 
  ggplot(aes(lon, lat, fill = PO4)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom") +
  labs(title = "150m values")

predictors %>%
  filter(depth == 150) %>% 
  ggplot(aes(lon, lat, fill = gamma)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom") +
  labs(title = "150m values")

```


### Predictor profiles

Likewise, predictor profiles for the North Atlantic are plotted to control successful merging of the data sets.

```{r predictor_profiles_N_Atl, fig.asp=1.5}

N_Atl <- predictors %>% 
  filter(lat == parameters$lat_Atl_profile,
         lon == parameters$lon_Atl_section)

N_Atl <- N_Atl %>% 
  select(-basin) %>% 
  pivot_longer(sal:gamma, names_to = "parameter", values_to = "value")

N_Atl %>% 
  ggplot(aes(value, depth)) +
  geom_path() +
  geom_point() +
  scale_y_reverse() +
  facet_wrap(~parameter,
             scales = "free_x",
             ncol = 2)

rm(N_Atl)

```


## WOA18 + GLODAP

WOA18 data are currently not used. Code chunks in this section are not executed.

```{r join_WOA18_GLODAP_predictors, fig.asp=0.5, eval=FALSE}

predictors <- full_join(GLODAP_predictors, WOA18_predictors)
rm(GLODAP_predictors, WOA18_predictors)

predictors <- predictors %>% 
  group_by(lat, lon) %>% 
  mutate(n_NO3 = sum(!is.na(NO3)),
         n_oxygen = sum(!is.na(oxygen)),
         n_PO4 = sum(!is.na(PO4)),
         n_silicate = sum(!is.na(silicate)),
         n_sal = sum(!is.na(sal)),
         n_tem = sum(!is.na(tem))) %>% 
  ungroup()

predictors <- predictors %>% 
  filter(n_NO3 > 1,
         n_oxygen > 1,
         n_PO4 > 1,
         n_silicate > 1, 
         n_sal > 1, 
         n_tem > 1) %>% 
  select(-c(n_NO3 , n_oxygen , n_PO4 , n_silicate , n_sal , n_tem))

predictors %>%
  ggplot(aes(lon, lat)) +
  geom_bin2d(binwidth = c(1,1)) +
  scale_fill_viridis_c(direction = -1) +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom")

predictors %>%
  filter(depth == 0) %>% 
  ggplot(aes(lon, lat, fill = PO4)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom") +
  labs(title = "Surface values")

predictors %>%
  filter(depth == 0) %>% 
  ggplot(aes(lon, lat, fill = tem)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_quickmap(expand = 0) +
  theme(legend.position = "bottom") +
  labs(title = "Surface values")


```

```{r interpolate_WOA18_vertically, eval=FALSE}

predictors <- predictors %>% 
  group_by(lat, lon) %>% 
  arrange(depth) %>% 
  mutate(tem = approxfun(depth, tem, rule = 2)(depth),
         sal = approxfun(depth, sal, rule = 2)(depth)) %>% 
  ungroup()


predictors <- predictors %>% 
  filter(depth %in% GLODAP_depths)


```

# Prepare predictor fields

## PO~4~* calculation 

Currently, the predictor PO~4~* is calculated according to Clement and Gruber (2018), ie based on oxygen rather than nitrate.

```{r calculate_phosphate_star_clement}

predictors <- predictors %>% 
  rename(phosphate = PO4) %>% 
  mutate(phosphate_star = phosphate + (oxygen / 170)  - 1.95)

```


## AOU

### Calculation

AOU was calculated as the difference between saturation concentration and observed concentration.  

**CAVEAT**: Algorithms used to calculate oxygen saturation concentration are not yet identical in GLODAP data set (fitting) and predictor climatologies (mapping).

```{r calculate_aou_climatology}

predictors <- predictors %>% 
  mutate(oxygen_sat = gas_satconc(S = sal,
                                  t = tem,
                                  P = 1.013253,
                                  species = "O2"),
         aou = oxygen_sat - oxygen) %>% 
  select(-oxygen_sat)


```

### Atlantic section

```{r aou_climatology_section, fig.asp=0.6}

predictors %>% 
  filter(lon == parameters$lon_Atl_section) %>% 
  ggplot(aes(lat, depth, z = aou)) +
  geom_contour_filled() +
  scale_fill_viridis_d(name = "AOU") +
  guides(fill = guide_colorsteps(barheight = unit(7, "cm"))) +
  scale_y_reverse() +
  coord_cartesian(expand = 0)

```

## Isoneutral slabs

The following boundaries for isoneutral slabs were defined:

- Atlantic: `r parameters$slabs_Atl`
- Indo-Pacific: `r parameters$slabs_Ind_Pac`

Continuous neutral density (gamma) values based on WOA13 are grouped into isoneutral slabs.

```{r cut_isoneutral_slabs}

predictors_Atl <- predictors %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma, parameters$slabs_Atl))

predictors_Ind_Pac <- predictors %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma, parameters$slabs_Ind_Pac))

predictors <- bind_rows(predictors_Atl, predictors_Ind_Pac)

rm(predictors_Atl, predictors_Ind_Pac)

```


# Prepare model coefficients

```{r prepare_model_coefficients}

all_lm <- all_lm %>% 
  select(term, estimate, basin, era, eras, gamma_slab, model)

all_lm <- all_lm %>% 
  mutate(estimate = if_else(is.na(estimate), 0, estimate))

all_lm_wide <- all_lm %>% 
  pivot_wider(names_from = era, values_from = estimate,
              names_prefix = "coeff_")

all_lm_wide <- all_lm_wide %>% 
  mutate(JGOFS_GO = coeff_GO_SHIP - coeff_JGOFS_WOCE,
         GO_new = coeff_new_era - coeff_GO_SHIP) %>% 
  select(-c(coeff_JGOFS_WOCE,
            coeff_GO_SHIP,
            coeff_new_era))

all_lm_long <- all_lm_wide %>% 
  pivot_longer(JGOFS_GO:GO_new, names_to = "eras_fit", values_to = "delta_coeff")

all_lm_long <- all_lm_long %>% 
  filter(eras == eras_fit) %>% 
  select(-eras_fit)

all_lm_wide <- all_lm_long %>% 
  pivot_wider(values_from = delta_coeff,
              names_from = term,
              names_prefix = "delta_coeff_",
              values_fill = 0)

rm(all_lm_long, all_lm)

```

## Merge MLRs + climatology

```{r merge_model_coeff_predictor_climatology}

Cant <- full_join(predictors, all_lm_wide)

rm(predictors, all_lm_wide)

```

# Map Cant

## Apply MLRs to predictor

```{r calculate_Cant}

Cant <- Cant %>% 
  mutate(Cant = `delta_coeff_(Intercept)` +
           delta_coeff_aou * aou +
           delta_coeff_oxygen * oxygen +
           delta_coeff_phosphate * phosphate +
           delta_coeff_phosphate_star * phosphate_star +
           delta_coeff_silicate * silicate +
           delta_coeff_sal * sal + 
           delta_coeff_tem * tem)

```

## Mean Cant fields

Mean and sd are calculated for Cant in each grid cell (XYZ), basin and era combination. Calculations are performed for all Cant values vs positive values only. This averaging step summarizes the information derived from ten best fitting MLRs. 

```{r Calculate_Cant_mean}

Cant_model_average <- Cant %>% 
  mutate(Cant_pos = if_else(Cant < 0, 0, Cant)) %>% 
  group_by(lon, lat, depth, eras, basin) %>% 
  summarise(Cant_mean = mean(Cant),
            Cant_sd = sd(Cant),
            Cant_pos_mean = mean(Cant_pos),
            Cant_pos_sd = sd(Cant_pos),
            gamma_mean = mean(gamma)) %>% 
  ungroup()

```

## Mean Cant sections

For each basin and era combination, the zonal mean Cant is calculated, again for all vs positive only values. Likewise, sd is calculated for the averaging of the mean basin fields.

```{r Calculate_Cant_mean_sections}

Cant_model_average_zonal <- Cant_model_average %>% 
  group_by(lat, depth, eras, basin) %>% 
  summarise(Cant_mean_sd = sd(Cant_mean, na.rm = TRUE),
            Cant_mean = mean(Cant_mean, na.rm = TRUE),
            Cant_sd_mean = mean(Cant_sd, na.rm = TRUE),
            Cant_pos_mean_sd = sd(Cant_pos_mean, na.rm = TRUE),
            Cant_pos_mean = mean(Cant_pos_mean, na.rm = TRUE),
            Cant_pos_sd_mean = mean(Cant_pos_sd, na.rm = TRUE),
            gamma_mean = mean(gamma_mean)) %>% 
  ungroup()

```


# Neutral density section

## Mean values

The mean zonal distribution of neutral densities was calculated. **CAVEAT:** Binning here does not reflect the isoneutral density slabs used for MLR fitting.

```{r gamma_sections_mean}

Cant_model_average_zonal %>% 
  filter(depth <= parameters$inventory_depth) %>% 
  ggplot(aes(lat, depth, z = gamma_mean)) +
  geom_contour_filled(binwidth = 0.25) +
  scale_fill_viridis_d(name = "Gamma",
                       direction = -1) +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```

# Cant sections

## Mean values

```{r Cant_sections_mean}

Cant_model_average_zonal %>% 
  filter(depth <= parameters$inventory_depth) %>% 
  ggplot(aes(lat, depth, z = Cant_mean)) +
  geom_contour_fill(breaks = MakeBreaks(5),
                    na.fill = TRUE) +
  scale_fill_divergent(guide = "colorstrip",
                       breaks = MakeBreaks(5),
                       name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```

## Mean zonal standard deviation across MLR models

Standard deviation across Cant from all MLR models was calculate for each grid cell (XYZ). The zonal mean of this standard deviation should reflect the uncertainty associated to the predictor selection within each slab and era. 

```{r Cant_sections_sd_models}

Cant_model_average_zonal %>% 
  filter(depth <= parameters$inventory_depth) %>% 
  ggplot(aes(lat, depth, z = Cant_sd_mean)) +
  geom_contour_filled() +
  scale_fill_viridis_d(name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```

## Zonal standard deviation of mean Cant estimates

Standard deviation of mean Cant values was calculate across all longitudes. This standard deviation should reflect the zonal variability of Cant within the basin and era.

```{r Cant_sections_sd_Cant}

Cant_model_average_zonal %>% 
  filter(depth <= parameters$inventory_depth) %>% 
  ggplot(aes(lat, depth, z = Cant_mean_sd)) +
  geom_contour_filled() +
  scale_fill_viridis_d(name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```


## Mean positive values

```{r Cant_sections_positive_mean}

Cant_model_average_zonal %>% 
  filter(depth <= parameters$inventory_depth) %>% 
  ggplot(aes(lat, depth, z = Cant_pos_mean)) +
  geom_contour_filled() +
  scale_fill_viridis_d(name = "Cant") +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  facet_grid(basin~eras)

```

# Cant maps

## Depth layers

Cant concentration for selected depth levels at which mapping was performed.

```{r Cant_depth_layer_maps, fig.asp=1}

Cant_model_average %>%
  filter(depth %in% c(150, 500, 1000, 3000)) %>% 
  ggplot(aes(lon, lat, fill = Cant_mean)) + 
  geom_raster() +
  scale_fill_divergent(guide = "colorstrip",
                       breaks = MakeBreaks(5),
                       name = "Cant") +
  guides(fill = guide_colorsteps(barheight = unit(10, "cm"))) +
  coord_quickmap(expand = 0) +
  facet_grid(depth~eras)

```

## Inventory calculation

To calculate Cant column inventories, we:  

1. Multiple layer thickness with Cant concentration to get a layer inventory
2. For each horizontal grid cell and era, sum Cant layer inventories from 150 - 3000 m

Step 2 is performed again for all Cant and positive Cant values only

```{r calculate_inventories}

depth_level_volume <- tibble(depth = unique(Cant_model_average$depth))

depth_level_volume <- depth_level_volume %>%
  mutate(
    layer_thickness_above = replace_na((depth - lag(depth)) / 2, 0),
    layer_thickness_below = replace_na((lead(depth) - depth) / 2, 0),
    layer_thickness = layer_thickness_above + layer_thickness_below
  ) %>%
  select(-c(layer_thickness_above,
            layer_thickness_below))

Cant_model_average <-
  full_join(Cant_model_average, depth_level_volume)

Cant_model_average <- Cant_model_average %>%
  mutate(layer_inv = Cant_mean * layer_thickness) %>%
  mutate(layer_inv_pos = if_else(layer_inv < 0, 0, layer_inv)) %>%
  select(-layer_thickness)

Cant_inv <- Cant_model_average %>%
  filter(depth <= parameters$inventory_depth) %>%
  group_by(lon, lat, basin, eras) %>%
  summarise(
    cant_inv_pos = sum(layer_inv_pos, na.rm = TRUE) / 1000,
    cant_inv     = sum(layer_inv, na.rm = TRUE) / 1000
  ) %>%
  ungroup()


```


## Inventories

### All Cant estimates

```{r Cant_inventory_map, fig.asp=1}

library(scales)

Cant_inv %>% 
  ggplot() +
    geom_raster(data = landmask %>% filter(region == "land"),
                aes(lon, lat), fill = "grey80") +
    geom_raster(aes(lon, lat, fill = cant_inv)) +
    coord_quickmap(expand = 0) +
    scale_fill_gradient2(high = muted("red"),
                         mid = "white",
                         low = muted("blue"),
                         midpoint = 0,
                         space = "Lab",
                         na.value = "green") +
  facet_wrap(~eras, ncol = 1) +
    theme(
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank()
    )

```


### Positive Cant estimates

```{r Cant_pos_inventory_map, fig.asp=1}

Cant_inv %>% 
  ggplot() +
    geom_raster(data = landmask %>% filter(region == "land"),
                aes(lon, lat), fill = "grey80") +
    geom_raster(aes(lon, lat, fill = cant_inv_pos)) +
    coord_quickmap(expand = 0) +
    scale_fill_viridis_c() +
  facet_wrap(~eras, ncol = 1) +
    theme(
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank()
    )

```

# Write csv

```{r write_cant_inventory}

Cant_model_average %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_2020.csv"))

Cant_inv %>%
    write_csv(here::here("data/mapping/_summarized_files",
                         "Cant_inv_2020.csv"))

```


# Open tasks

- Calculate WOA18 neutral density and use WOA18 S, T, and gamma as predictors
- Switch to Clement's basin mask or update WOA18 basin mask
- Check PO4* calculation
- Harmonize AOU calculation in fitting and mapping
- Plot Cant sections for individual MLR models



# Open questions

- 
