---
title: "Data base"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

```

```{r library, message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(patchwork)
library(broom)
library(GGally)
library(olsrr)
library(knitr)
library(kableExtra)
library(broom)
library(corrr)
  
```


```{r ggplot_theme, include = FALSE}
theme_set(theme_bw())
```

# Required data

Required are: 

- clean version of GLODAPGLODAPv2.2020
- observations grid of clean version of GLODAPGLODAPv2.2020
- C_ant from GLODAPv2_2016b_MappedClimatologies
- annual mean atmospheric pCO~2~ 

```{r read_required_data_sets}

GLODAP <- read_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
                              "GLODAPv2.2020_clean.csv"))

GLODAP_obs_grid <- read_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
                                           "GLODAPv2.2020_clean_obs_grid.csv"))

Cant_clim <- read_csv(here::here("data/GLODAPv2_2016b_MappedClimatologies/_summarized_files",
                                 "Cant.csv"))

co2_atm <- read_csv(here::here("data/pCO2_atmosphere/_summarized_data_files",
                               "co2_atm.csv"))

```

# C*

C* serves as a conservative tracer of anthropogenic CO~2~ uptake. It is derived from measured DIC by removing the impact of 
- organic matter formation and respiration
- calcification and calcium carbonate dissolution

Contributions of those processes are estimated from phosphate and alkalinity concentrations.

## Stoichiometric ratios

```{r set_criteria_stoichiometric_ratios}

rCP <- 117
rNP <- 16

```

The stoichiometric nutrient ratios for the production and mineralization of organic matter were set to:

- C/P: `r rCP`
- N/P: `r rNP`

## Calculation

```{r calculate_Cstar}

print("Cstar = tco2  + rCP_phosphate  + talk_05  + rNP_phosphate_05")

GLODAP <- GLODAP %>% 
  mutate(rCP_phosphate = -rCP * phosphate,
         talk_05 = -0.5 * talk,
         rNP_phosphate_05 = -0.5 * rNP * phosphate,
         Cstar = tco2  + rCP_phosphate  + talk_05  + rNP_phosphate_05)

```

## PO~4~* calculation 

Currently, PO~4~* is calculated according to Gruber et al. (2019), ie based on nitrate rather than oxygen.

```{r calculate_phosphate_star}

GLODAP <- GLODAP %>% 
  mutate(phosphate_star = phosphate - 16*nitrate  + 29)

```


# Reference year adjustment

The scaling factor for the reference year adjustment is an apriori estiamte of Cant at a given location and depth. Here, Cant from the GLODAP mapped Climatology was used.  

Note that eq. 6 in Clement and Gruber (2018) misses pCO2 pre-industrial in the denominator. Here we use the equation published in Gruber et al. (2019).

## Merge GLODAP + Cant

```{r merge_Cstar_Cant}

Cant_clim <- Cant_clim %>% 
  drop_na()

Cant_clim_obs <- left_join(GLODAP_obs_grid, Cant_clim) %>% 
  select(-n)

rm(Cant_clim, GLODAP_obs_grid)

GLODAP_Cant_obs <- full_join(GLODAP, Cant_clim_obs)

rm(Cant_clim_obs)

# GLODAP_Cant_full %>% write_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
#                                           "GLODAP_Cant_full.csv"))
# 
# GLODAP_Cant_full <- read_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
#                                           "GLODAP_Cant_full.csv"))

```

The mapped Cant product was merged with GLODAP observation by:

- using an identical 1x1° horizontal grid
- linear interpolation of Cant from standard to sampling depth

```{r interpolate_Cant_to_observations}

GLODAP_Cant_obs <- GLODAP_Cant_obs %>% 
  group_by(lat, lon) %>% 
  arrange(depth) %>% 
  mutate(Cant_int = approxfun(depth, Cant, rule = 2)(depth)) %>% 
  ungroup()

ggplot() +
    geom_path(data = GLODAP_Cant_obs %>% 
              filter(lat == 48.5, lon == 165.5, !is.na(Cant)) %>% 
              arrange(depth),
            aes(Cant, depth, col = "mapped")) +
  geom_point(data = GLODAP_Cant_obs %>% 
              filter(lat == 48.5, lon == 165.5, !is.na(Cant)) %>% 
              arrange(depth),
            aes(Cant, depth, col = "mapped")) +
  geom_point(data = GLODAP_Cant_obs %>% 
              filter(lat == 48.5, lon == 165.5, date == ymd("2018-06-27")),
            aes(Cant_int, depth, col = "interpolated")) +
  scale_y_reverse() +
  scale_color_brewer(palette = "Dark2", name = "") +
  labs(title = "Cant interpolation to sampling depth - example profile")

GLODAP <- GLODAP_Cant_obs %>% 
  filter(!is.na(Cstar)) %>% 
  mutate(Cant = Cant_int) %>% 
  select(-Cant_int)

rm(GLODAP_Cant_obs)

```

## Merge GLODAP + atmospheric pCO~2~

```{r merge_Cstar_pCO2}

GLODAP <- left_join(GLODAP, co2_atm)

```


## Calculate adjustment

```{r adjust_reference_year}

GLODAP <- GLODAP %>% 
  group_by(era) %>% 
  mutate(tref = median(year)) %>% 
  ungroup()

tref <- GLODAP %>% 
  group_by(era) %>% 
  summarise(year = median(year)) %>% 
  ungroup()

co2_atm_tref <- right_join(co2_atm, tref) %>% 
  select(-year) %>% 
  rename(pCO2_tref = pCO2)

GLODAP <- full_join(GLODAP, co2_atm_tref)

rm(co2_atm, co2_atm_tref, tref)

GLODAP <- GLODAP %>% 
  mutate(Cstar_tref_delta = 
           ((pCO2 - pCO2_tref) / (pCO2_tref - 280)) * Cant,
         Cstar_tref = Cstar - Cstar_tref_delta)

```

## Control plots

```{r Cstar_reference_year_adjustment_histogram}

GLODAP %>% 
  ggplot(aes(Cstar_tref_delta)) +
  geom_histogram()

```


```{r Cstar_reference_year_adjustment_vs_time_difference_Cant}

GLODAP %>% 
  sample_n(10000) %>% 
  ggplot(aes(year, Cstar_tref_delta, col = Cant)) +
  geom_point() +
  scale_color_viridis_c() +
  labs(title = "random subsample 1e4")

```


# Selected section plots

Selected sections are plotted to demonstrate the magnitude of various parameters and corrections relevant to C*.

```{r select_cruises}

cruises_meridional <- c("1041")

GLODAP_cruise <- GLODAP %>% 
  filter(cruise %in% cruises_meridional)

```

```{r interpolate_raster_section, eval=FALSE}

bbox <- c(
  "xmin" = min(GLODAP_cruise$lat),
  "ymin" = min(GLODAP_cruise$depth),
  "xmax" = max(GLODAP_cruise$lat),
  "ymax" = max(GLODAP_cruise$depth)
)

grd_template <- expand.grid(
  lat = seq(from = bbox["xmin"], to = bbox["xmax"], by = 1),
  depth = seq(from = bbox["ymin"], to = bbox["ymax"], by = 50) # 20 m resolution
)

crs_raster_format <- " +proj=utm  +zone=33  +ellps=GRS80  +towgs84=0,0,0,0,0,0,0  +units=m  +no_defs"

grd_template_raster <- grd_template %>% 
  dplyr::mutate(Z = 0) %>% 
  raster::rasterFromXYZ( 
    crs = crs_raster_format)


# Generalized Additive Model
fit_GAM <- mgcv::gam( # using {mgcv}
  gamma ~ s(lat, depth),      # here come our X/Y/Z data - straightforward enough
  data = GLODAP_cruise      # specify in which object the data is stored
)

# Generalized Additive Model
interp_GAM <- grd_template %>% 
  mutate(Z = predict(fit_GAM, .)) %>% 
  raster::rasterFromXYZ(crs = crs_raster_format)

df <- raster::rasterToPoints(interp_GAM) %>% as_tibble()
colnames(df) <- c("X", "Y", "Z")
  
ggplot(df, aes(x = X, y = Y, fill = Z, z = Z))  +
  geom_raster()  +
  geom_contour(col="white")  +
  ggtitle(label = "interp GAM")  +
  scale_fill_viridis_c()  +
  scale_y_reverse() +
  coord_cartesian(expand = 0)

```




```{r meridional_sections, fig.asp=0.6}

mapWorld <- borders("world", colour = "gray60", fill = "gray60")

GLODAP_cruise %>%
  arrange(date) %>% 
  ggplot(aes(lon, lat)) +
  mapWorld +
  geom_path() +
  geom_point(aes(col = date)) +
  coord_quickmap(expand = 0) +
  scale_color_viridis_c(trans = "date") +
  labs(title = paste("Cruise year:", mean(GLODAP_cruise$year))) +
  theme(legend.position = "bottom")

lat_section <- 
GLODAP_cruise %>%
  ggplot(aes(lat, depth)) +
  scale_y_reverse() +
  scale_color_viridis_c() +
  theme(legend.position = "bottom")

lat_section +
  geom_point(aes(col = tco2))

lat_section +
  geom_point(aes(col = talk))

lat_section +
  geom_point(aes(col = phosphate))

lat_section +
  geom_point(aes(col = rCP_phosphate))

lat_section +
  geom_point(aes(col = talk_05))

lat_section +
  geom_point(aes(col = rNP_phosphate_05))

lat_section +
  geom_point(aes(col = Cstar))

lat_section +
  geom_point(aes(col = Cant))

lat_section +
  geom_point(aes(col = -Cstar_tref_delta))


rm(mapWorld, lat_section, GLODAP_cruise)

```




# MLR

## Isoneutral slabs

```{r define_isoneutral_slabs}

slabs_Atl <- c(
-Inf,
26.00,
26.50,
26.75,
27.00,
27.25,
27.50,
27.75,
27.85,
27.95,
28.05,
28.10,
28.15,
28.20,
Inf)

slabs_Ind_Pac <- c(
-Inf,
26.00,
26.50,
26.75,
27.00,
27.25,
27.50,
27.75,
27.85,
27.95,
28.05,
28.10,
Inf)


```

The following boundaries for isoneutral slabs were defined:

- Atlantic: `r slabs_Atl`
- Indo-Pacific: `r slabs_Ind_Pac`

```{r cut_isoneutral_slabs}

GLODAP_Atl <- GLODAP %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma, slabs_Atl))

GLODAP_Ind_Pac <- GLODAP %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma, slabs_Ind_Pac))

GLODAP <- bind_rows(GLODAP_Atl, GLODAP_Ind_Pac)
rm(GLODAP_Atl, GLODAP_Ind_Pac)

```

```{r isoneutral_slabs_section, fig.asp=0.6}

GLODAP_cruise <- GLODAP %>% 
  filter(cruise %in% cruises_meridional)

lat_section <- 
GLODAP_cruise %>%
  ggplot(aes(lat, depth)) +
  scale_y_reverse() +
  theme(legend.position = "bottom")

lat_section +
  geom_point(aes(col = gamma)) +
  scale_color_viridis_c()

lat_section +
  geom_point(aes(col = gamma_slab)) +
  scale_color_viridis_d()


```


## Predictor correlation

### Without grouping

```{r predictor_correlation_all, fig.asp=1}

GLODAP %>% 
  sample_frac(0.01) %>% 
  ggpairs(columns = c("Cstar",
                      "salinity",
                      "temperature",
                      "aou",
                      "oxygen",
                      "silicate",
                      "phosphate",
                      "phosphate_star"),
          ggplot2::aes(col = gamma_slab, fill = gamma_slab, alpha = 0.01)) +
      scale_fill_viridis_d() +
      scale_color_viridis_d() +
      labs(title = paste("Basin: all | era: all | subsample size: 1 % of", nrow(GLODAP)))


```

### Grouped for basin, era, slab

Individual correlation plots for each basin, era and neutral density (gamma) slab are available upon request.

```{r predictor_correlation_basin_era_per_slab, eval=FALSE}


for (i_basin in unique(GLODAP$basin)) {
  for (i_era in unique(GLODAP$era)) {

# i_basin <- unique(GLODAP$basin)[1]
# i_era   <- unique(GLODAP$era)[1]

print(i_basin)
print(i_era)

GLODAP_basin_era <- GLODAP %>% 
  filter(basin == i_basin,
         era == i_era)

for (i_gamma_slab in unique(GLODAP_basin_era$gamma_slab)) {
  
  #i_gamma_slab <- unique(GLODAP_basin_era$gamma_slab)[5]
  print(i_gamma_slab)
  
  GLODAP_highlight <- GLODAP_basin_era %>% 
  mutate(gamma_highlight = if_else(gamma_slab == i_gamma_slab,
                                   "in", "out")) %>%
    arrange(desc(gamma_highlight))
  
p <- GLODAP_highlight %>% 
  ggpairs(columns = c("Cstar",
                      "salinity",
                      "temperature",
                      "aou",
                      "oxygen",
                      "silicate",
                      "phosphate",
                      "phosphate_star"),
          ggplot2::aes(col = gamma_highlight, fill = gamma_highlight, alpha = 0.01)) +
      scale_fill_manual( values = c("red", "grey")) +
      scale_color_manual(values = c("red", "grey")) +
      labs(title = paste(i_basin,
                         "| ", i_era,
                         "| Gamma slab", i_gamma_slab,
                         "| total nr", nrow(GLODAP_basin_era),
                         "| slab nr", nrow(GLODAP_highlight %>% 
                                             filter(gamma_highlight == "slab"))))
  

png(here::here("output/figure/eMLR/predictor_correlation",
               paste("predictor_correlation", i_basin, i_era, i_gamma_slab, ".png", sep = "_")),
    width = 12, height = 12, units = "in", res = 300)

print(p)

dev.off()
  
    }
  }
}


```

### Correlation coeffcients

```{r calculate_correlation_coefficients}

for (i_basin in unique(GLODAP$basin)) {
  for (i_era in unique(GLODAP$era)) {

# i_basin <- unique(GLODAP$basin)[1]
# i_era   <- unique(GLODAP$era)[1]
print(i_basin)
print(i_era)

GLODAP_basin_era <- GLODAP %>% 
  filter(basin == i_basin,
         era == i_era) %>% 
  select(basin,
         era,
         gamma_slab,
         Cstar,
         salinity,
         temperature,
         aou,
         oxygen,
         silicate,
         phosphate,
         phosphate_star)

for (i_gamma_slab in unique(GLODAP_basin_era$gamma_slab)) {
  
  # i_gamma_slab <- unique(GLODAP_basin_era$gamma_slab)[5]
  print(i_gamma_slab)
  
  GLODAP_basin_era_slab <- GLODAP_basin_era %>%
    filter(gamma_slab == i_gamma_slab)

  cor_Cstar_predictor_temp <- GLODAP_basin_era_slab %>% 
    select(-c(basin, era, gamma_slab)) %>% 
    correlate() %>% 
    focus(Cstar) %>% 
    mutate(basin = i_basin,
       era = i_era,
       gamma_slab = i_gamma_slab)
  
  if (exists("cor_Cstar_predictor")) {
        cor_Cstar_predictor <- bind_rows(cor_Cstar_predictor, cor_Cstar_predictor_temp)
      }
      
    if (!exists("cor_Cstar_predictor")) {
        cor_Cstar_predictor <- cor_Cstar_predictor_temp
    }
  
  
  cor_predictors_temp <- GLODAP_basin_era_slab %>% 
    select(-c(basin, era, gamma_slab)) %>% 
    correlate() %>% 
    shave %>% 
    stretch() %>% 
    filter(!is.na(r),
           x != "Cstar",
           y != "Cstar") %>% 
    mutate(pair = paste(x, y, sep = " + ")) %>% 
    select(-c(x, y)) %>% 
    mutate(basin = i_basin,
       era = i_era,
       gamma_slab = i_gamma_slab)
  
    if (exists("cor_predictors")) {
        cor_predictors <- bind_rows(cor_predictors, cor_predictors_temp)
      }
      
    if (!exists("cor_predictors")) {
        cor_predictors <- cor_predictors_temp
    }
  
  
  
    }
  }
}


cor_predictors %>%
  write_csv(here::here("data/eMLR",
                       "cor_predictors.csv"))

cor_Cstar_predictor %>%
  write_csv(here::here("data/eMLR",
                       "cor_Cstar_predictor.csv"))

rm(cor_predictors_temp, cor_Cstar_predictor_temp)

```


```{r predictors_correlation_coefficient, fig.asp=2}

cor_predictors_stats <- cor_predictors %>% 
  group_by(pair, basin, gamma_slab) %>% 
  summarise(mean_r = mean(r),
            min_r = min(r),
            max_r = max(r)) %>% 
  ungroup()

cor_predictors_stats %>% 
  mutate(pair = reorder(pair, mean_r)) %>%
  ggplot() +
  geom_vline(xintercept = c(-0.9, 0.9), col = "red") +
  geom_vline(xintercept = 0) +
  geom_linerange(
    aes(y = pair, xmin = min_r, xmax = max_r, col = gamma_slab),
    position = position_dodge(width = 0.6)) +
  facet_wrap(~basin) +
  scale_color_viridis_d(direction = -1) +
  labs(x = "correlation coefficient", y = "") +
  theme(legend.position = "top")


```


```{r Cstar_predictor_correlation_coefficient, fig.asp=1.5}

cor_Cstar_predictor_stats <- cor_Cstar_predictor %>% 
  group_by(rowname, basin, gamma_slab) %>% 
  summarise(mean_r = mean(Cstar),
            min_r = min(Cstar),
            max_r = max(Cstar)) %>% 
  ungroup()

cor_Cstar_predictor_stats %>% 
  mutate(rowname = reorder(rowname, mean_r)) %>%
  ggplot() +
  geom_vline(xintercept = c(-0.9, 0.9), col = "red") +
  geom_vline(xintercept = 0) +
  geom_linerange(
    aes(y = rowname, xmin = min_r, xmax = max_r, col = gamma_slab),
    position = position_dodge(width = 0.6)) +
  facet_wrap(~basin) +
  scale_color_viridis_d(direction = -1) +
  labs(x = "correlation coefficient", y = "") +
  theme(legend.position = "top")


```



## Model fitting

```{r write_csv_GLODAP_used_for_fitting, eval = FALSE}

GLODAP %>% write_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
                                "GLODAP_MLR_fitting_ready.csv"))

```

### Predictor selection

```{r eMLR_fitting_predictor_selection, eval=FALSE}

# gamma_slab_max <- GLODAP %>%
#   filter(basin == "Atlantic", era == "new_era") %>% 
#   group_by(gamma_slab) %>% 
#   count() %>% 
#   ungroup() %>% 
#   filter(n == max(n)) %>% 
#   pull(1)


for (i_basin in unique(GLODAP$basin)) {
  for (i_era in unique(GLODAP$era)) {
    
    # i_basin <- unique(GLODAP$basin)[1]
    # i_era   <- unique(GLODAP$era)[1]
    
    print(i_basin) 
    print(i_era  )
    
    GLODAP_basin_era <- GLODAP %>%
      filter(basin == i_basin, era == i_era)

    for (i_gamma_slab in unique(GLODAP_basin_era$gamma_slab)) {

      # i_gamma_slab <- unique(GLODAP_basin_era$gamma_slab)[1]
      print(i_gamma_slab)
      
      GLODAP_basin_era_slab <- GLODAP_basin_era %>% 
        filter(gamma_slab == i_gamma_slab)
      
      lm_full <- lm(Cstar ~ 
                salinity  + 
                temperature  + 
                aou  + 
                oxygen  + 
                silicate  + 
                phosphate  + 
                phosphate_star, 
              data = GLODAP_basin_era_slab)
      
      lm_all <- ols_step_all_possible(lm_full)
      
      temp <- as_tibble(lm_all$result)
      
      temp <- temp %>% 
        mutate(basin = i_basin,
               era = i_era,
               gamma_slab = i_gamma_slab)
      
      if (exists("all_lm_stats")) {
        all_lm_stats <- bind_rows(all_lm_stats, temp)
      }
      
      if (!exists("all_lm_stats")) {
        all_lm_stats <- temp
      }
      
      rm(lm_full, lm_all, temp)
      
    }
    
  }
  
}

all_lm_stats %>%
  write_csv(here::here("data/eMLR",
                       "all_lm_stats.csv"))

```

```{r eMLR_predictor_model_quality, fig.asp=2}

all_lm_stats <- read_csv(here::here("data/eMLR",
                                    "all_lm_stats.csv"))


# all_lm_stats <- all_lm_stats %>% 
#   rename(sigma = rmse)

all_lm_stats %>% 
  ggplot(aes(n, rmse, col = basin)) +
  geom_hline(yintercept = 10) + 
  geom_point(shape = 21) +
  facet_grid(gamma_slab~era) +
  scale_color_brewer(palette = "Set1")

all_lm_stats %>% 
  ggplot(aes(n, adjr, col = basin)) +
  geom_point(shape = 21) +
  facet_grid(gamma_slab~era) +
  scale_color_brewer(palette = "Set1")

all_lm_stats %>% 
  ggplot(aes(n, aic, col = basin)) +
  geom_point(shape = 21) +
  facet_grid(gamma_slab~era) +
  scale_color_brewer(palette = "Set1")

 
# all_lm_stats %>% 
#   ggplot(aes(rmse, predictors, col = gamma_slab)) +
#   geom_point(shape = 21) +
#   facet_grid(.~basin)
  

```




```{r predictor_selection}

n_predictors_max <- 5
n_predictors_min <- 2

all_lm_stats <- all_lm_stats %>% 
  filter(n >= n_predictors_min,
         n <= n_predictors_max) %>% 
  select(basin, era, gamma_slab, predictors, rmse)

all_lm_stats_wide <- all_lm_stats %>% 
  pivot_wider(names_from = era, values_from = rmse, names_prefix = "rmse_")

all_lm_stats_wide <- all_lm_stats_wide %>% 
  mutate(rmse_sum = rmse_JGOFS_WOCE + rmse_GO_SHIP + rmse_new_era)

lm_best <- all_lm_stats_wide %>% 
  group_by(basin, gamma_slab) %>% 
  slice_min(rmse_sum, n = 10) %>% 
  ungroup()

kable(lm_best) %>%
  add_header_above() %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")

rm(n_predictors_max, n_predictors_min)

```

```{r fit_best_models, eval=FALSE}

lm_best <- lm_best %>% 
  mutate(lm_coeff = str_replace_all(predictors, " ", " + "),
         lm_coeff = paste("Cstar ~", lm_coeff))

# test_lm <- lm_best %>% 
#   slice_min(rmse_sum) %>% 
#   select(lm_coeff) %>% 
#   pull()
# 
# class(test_lm)
# test_lm_formula <- as.formula(test_lm)
# class(test_lm_formula)

for (i_basin in unique(GLODAP$basin)) {
  for (i_era in unique(GLODAP$era)) {
    
    # i_basin <- unique(GLODAP$basin)[1]
    # i_era   <- unique(GLODAP$era)[1]
    
    print(i_basin) 
    print(i_era  )
    
    GLODAP_basin_era <- GLODAP %>%
      filter(basin == i_basin, era == i_era)

    lm_best_basin <- lm_best %>%
      filter(basin == i_basin)

    for (i_gamma_slab in unique(GLODAP_basin_era$gamma_slab)) {

      # i_gamma_slab <- unique(GLODAP_basin_era$gamma_slab)[1]
      print(i_gamma_slab)
      
      GLODAP_basin_era_slab <- GLODAP_basin_era %>% 
        filter(gamma_slab == i_gamma_slab)
      
      lm_best_basin_slab <- lm_best_basin %>% 
        filter(gamma_slab == i_gamma_slab)
      
      for (i_rmse_sum in unique(lm_best_basin_slab$rmse_sum)) {
        
        # i_rmse_sum <- unique(lm_best_basin_slab$rmse_sum)[2]
        
        lm_best_single <- lm_best %>%
          filter(rmse_sum == i_rmse_sum) %>%
          select(lm_coeff) %>%
          pull()
        
        lm_formula <- as.formula(lm_best_single)
        
        model_single <- lm(lm_formula, 
              data = GLODAP_basin_era_slab)
        
        coefficients <- tidy(model_single)
        coefficients <- coefficients %>% 
          mutate(basin = i_basin,
                 era = i_era,
                 gamma_slab = i_gamma_slab,
                 model = lm_best_single,
                 rmse = i_rmse_sum)
        
        print(lm_best_single)
      
      if (exists("all_lm")) {
        all_lm <- bind_rows(all_lm, coefficients)
      }
      
      if (!exists("all_lm")) {
        all_lm <- coefficients
      }
      
      rm(lm_formula, model_single, coefficients)
        
      }
      
 
    }
    
  }
  
}


all_lm %>%
  write_csv(here::here("data/eMLR",
                       "all_lm.csv"))

```



### All predictors

```{r eMLR_fitting_full_model, eval=FALSE}

MLRs <- GLODAP %>%
  nest(data = -c(basin, era, gamma_slab)) %>% 
  mutate(
    fit = map(data, ~ lm(Cstar ~ salinity  + temperature  + aou  + oxygen  + silicate  + phosphate  + phosphate_star,
                         data = .x)),
    tidied = map(fit, tidy),
    glanced = map(fit, glance),
    augmented = map(fit, augment)
  )

MLRs_tidied <- MLRs %>% 
  unnest(tidied)

MLRs_tidied

MLRs_tidied <- MLRs_tidied %>% 
  select(era, basin, gamma_slab, term, estimate, p.value)

MLRs_tidied_wide <- MLRs_tidied %>% 
  select(-p.value) %>% 
  pivot_wider(names_from = era, values_from = estimate, names_prefix = "coeff_")

MLRs_tidied_wide <- MLRs_tidied_wide %>% 
  mutate(delta_coeff_J_G = coeff_GO_SHIP - coeff_JGOFS_WOCE,
         delta_coeff_G_n = coeff_new_era - coeff_GO_SHIP,
         delta_coeff_n_G = coeff_new_era - coeff_JGOFS_WOCE)

MLRs_tidied %>% 
  ggplot(aes(p.value, term, col = gamma_slab)) +
  geom_point() +
  facet_grid(basin~era)

MLRs_tidied %>% 
  filter(p.value < 0.05) %>% 
  ggplot(aes(p.value, term, col = gamma_slab)) +
  geom_point() +
  facet_grid(basin~era)

MLRs_tidied %>% 
  ggplot(aes(p.value, term)) +
  geom_boxplot() +
  facet_grid(basin~era)

MLRs %>% 
  unnest(glanced)

MLRs %>% 
  unnest(augmented)

```

# Open tasks

-  Check if intercept is modeled
