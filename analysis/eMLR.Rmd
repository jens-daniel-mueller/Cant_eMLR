---
title: "Data base"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

```

```{r library, message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(patchwork)
library(broom)
library(GGally)
library(olsrr)
library(knitr)
library(kableExtra)
library(broom)
library(corrr)
  
```


```{r ggplot_theme, include = FALSE}
theme_set(theme_bw())
```

# Required data

Required are: 

- GLODAPv2.2020
  - cleaned data file
  - horizontal grid of sampling coordinates
- Cant from GLODAPv2_2016b_MappedClimatologies
- annual mean atmospheric pCO~2~ 

```{r read_required_data_sets}

GLODAP <- read_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
                              "GLODAPv2.2020_clean.csv"))

GLODAP_obs_grid <- read_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
                                           "GLODAPv2.2020_clean_obs_grid.csv"))

Cant_clim <- read_csv(here::here("data/GLODAPv2_2016b_MappedClimatologies/_summarized_files",
                                 "Cant.csv"))

co2_atm <- read_csv(here::here("data/pCO2_atmosphere/_summarized_data_files",
                               "co2_atm.csv"))

```

# C*

C* serves as a conservative tracer of anthropogenic CO~2~ uptake. It is derived from measured DIC by removing the impact of  

- organic matter formation and respiration
- calcification and calcium carbonate dissolution

Contributions of those processes are estimated from phosphate and alkalinity concentrations.

## Stoichiometric ratios

```{r set_criteria_stoichiometric_ratios}

rCP <- 117
rNP <- 16

```

The stoichiometric nutrient ratios for the production and mineralization of organic matter were set to:

- C/P: `r rCP`
- N/P: `r rNP`

## Calculation

C* is calculated as:  



```{r calculate_Cstar}

print("Cstar = tco2  + rCP_phosphate  + talk_05  + rNP_phosphate_05")

GLODAP <- GLODAP %>% 
  mutate(rCP_phosphate = -rCP * phosphate,
         talk_05 = -0.5 * talk,
         rNP_phosphate_05 = -0.5 * rNP * phosphate,
         Cstar = tco2  + rCP_phosphate  + talk_05  + rNP_phosphate_05)

rm(rCP, rNP)

```

# PO~4~* calculation 

Currently, the predictor PO~4~* is calculated according to Clement and Gruber (2018), ie based on oxygen rather than nitrate.

```{r calculate_phosphate_star_clement}

GLODAP <- GLODAP %>% 
  mutate(phosphate_star = phosphate + (oxygen / 170)  - 1.95)

```

```{r calculate_phosphate_star_gruber, eval=FALSE}

GLODAP <- GLODAP %>% 
  mutate(phosphate_star = phosphate - 16*nitrate  + 2.9)

```


# Reference year adjustment

The reference year adjustment relies on an apriori estimate of Cant at a given location and depth, which is used as a scaling factor for the concurrent change in atmospheric CO~2~. The underlying assumption is a transient steady state for the oceanic Cant uptake. Here, Cant from the GLODAP mapped Climatology was used.  

Note that eq. 6 in Clement and Gruber (2018) misses pCO~2~ pre-industrial in the denominator. Here we use the equation published in Gruber et al. (2019).

## Merge data sets

### GLODAP + Cant

```{r merge_Cstar_Cant}

Cant_clim <- Cant_clim %>% 
  drop_na()

Cant_clim_obs <- left_join(GLODAP_obs_grid, Cant_clim) %>% 
  select(-n)

rm(Cant_clim, GLODAP_obs_grid)

GLODAP_Cant_obs <- full_join(GLODAP, Cant_clim_obs)

rm(Cant_clim_obs, GLODAP)

```

The mapped Cant product was merged with GLODAP observation by:

- using an identical 1x1° horizontal grid
- linear interpolation of Cant from standard to sampling depth

```{r interpolate_Cant_to_observations}

GLODAP_Cant_obs <- GLODAP_Cant_obs %>% 
  group_by(lat, lon) %>% 
  arrange(depth) %>% 
  mutate(Cant_int = approxfun(depth, Cant, rule = 2)(depth)) %>% 
  ungroup()

ggplot() +
    geom_path(data = GLODAP_Cant_obs %>% 
              filter(lat == 48.5, lon == 165.5, !is.na(Cant)) %>% 
              arrange(depth),
            aes(Cant, depth, col = "mapped")) +
  geom_point(data = GLODAP_Cant_obs %>% 
              filter(lat == 48.5, lon == 165.5, !is.na(Cant)) %>% 
              arrange(depth),
            aes(Cant, depth, col = "mapped")) +
  geom_point(data = GLODAP_Cant_obs %>% 
              filter(lat == 48.5, lon == 165.5, date == ymd("2018-06-27")),
            aes(Cant_int, depth, col = "interpolated")) +
  scale_y_reverse() +
  scale_color_brewer(palette = "Dark2", name = "") +
  labs(title = "Cant interpolation to sampling depth - example profile")

GLODAP <- GLODAP_Cant_obs %>% 
  filter(!is.na(Cstar)) %>% 
  mutate(Cant = Cant_int) %>% 
  select(-Cant_int)

rm(GLODAP_Cant_obs)

```

### GLODAP + atm. pCO~2~

GLODAP observations were merged with mean annual atmospheric pCO~2~ levels by year.

```{r merge_Cstar_pCO2}

GLODAP <- left_join(GLODAP, co2_atm)

```


## Calculate adjustment

```{r adjust_reference_year}

GLODAP <- GLODAP %>% 
  group_by(era) %>% 
  mutate(tref = median(year)) %>% 
  ungroup()

tref <- GLODAP %>% 
  group_by(era) %>% 
  summarise(year = median(year)) %>% 
  ungroup()

co2_atm_tref <- right_join(co2_atm, tref) %>% 
  select(-year) %>% 
  rename(pCO2_tref = pCO2)

GLODAP <- full_join(GLODAP, co2_atm_tref)

rm(co2_atm, co2_atm_tref, tref)

GLODAP <- GLODAP %>% 
  mutate(Cstar_tref_delta = 
           ((pCO2 - pCO2_tref) / (pCO2_tref - 280)) * Cant,
         Cstar_tref = Cstar - Cstar_tref_delta)

```

## Control plots

### Histogram

```{r Cstar_reference_year_adjustment_histogram}

GLODAP %>% 
  ggplot(aes(Cstar_tref_delta)) +
  geom_histogram()

```

### Time series

```{r Cstar_reference_year_adjustment_vs_time_difference_Cant}

GLODAP %>% 
  sample_n(1e4) %>% 
  ggplot(aes(year, Cstar_tref_delta, col = Cant)) +
  geom_point() +
  scale_color_viridis_c() +
  labs(title = "random subsample 1e4")

```

# Selected section plots

A selected section is plotted to demonstrate the magnitude of various parameters and corrections relevant to C*.

```{r select_cruises}

cruises_meridional <- c("1041")

GLODAP_cruise <- GLODAP %>% 
  filter(cruise %in% cruises_meridional)

```


```{r meridional_sections, fig.asp=0.6}

landmask <- read_csv(here::here("data/World_Ocean_Atlas_2018/_summarized_files",
                                 "land_mask_WOA18.csv"))

GLODAP_cruise %>%
  arrange(date) %>% 
  ggplot(aes(lon, lat)) +
  geom_raster(data = landmask %>% filter(region == "land"),
              aes(lon, lat), fill = "grey80") +
  geom_path() +
  geom_point(aes(col = date)) +
  coord_quickmap(expand = 0) +
  scale_color_viridis_c(trans = "date") +
  labs(title = paste("Cruise year:", mean(GLODAP_cruise$year))) +
  theme(legend.position = "bottom")

lat_section <- 
GLODAP_cruise %>%
  ggplot(aes(lat, depth)) +
  scale_y_reverse() +
  scale_color_viridis_c() +
  theme(legend.position = "bottom")

lat_section +
  geom_point(aes(col = tco2))

lat_section +
  geom_point(aes(col = talk))

lat_section +
  geom_point(aes(col = phosphate))

lat_section +
  geom_point(aes(col = rCP_phosphate))

lat_section +
  geom_point(aes(col = talk_05))

lat_section +
  geom_point(aes(col = rNP_phosphate_05))

lat_section +
  geom_point(aes(col = Cstar))

lat_section +
  geom_point(aes(col = Cant))

lat_section +
  geom_point(aes(col = -Cstar_tref_delta))


rm(lat_section, GLODAP_cruise)

```




# MLR

## Isoneutral slabs

```{r define_isoneutral_slabs}

slabs_Atl <- c(
-Inf,
26.00,
26.50,
26.75,
27.00,
27.25,
27.50,
27.75,
27.85,
27.95,
28.05,
28.10,
28.15,
28.20,
Inf)

slabs_Ind_Pac <- c(
-Inf,
26.00,
26.50,
26.75,
27.00,
27.25,
27.50,
27.75,
27.85,
27.95,
28.05,
28.10,
Inf)


```

The following boundaries for isoneutral slabs were defined:

- Atlantic: `r slabs_Atl`
- Indo-Pacific: `r slabs_Ind_Pac`

Continous neutral densities (gamma) values from GLODAP are grouped into isoneutral slabs.

```{r cut_isoneutral_slabs}

GLODAP_Atl <- GLODAP %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma, slabs_Atl))

GLODAP_Ind_Pac <- GLODAP %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma, slabs_Ind_Pac))

GLODAP <- bind_rows(GLODAP_Atl, GLODAP_Ind_Pac)

rm(GLODAP_Atl, GLODAP_Ind_Pac, slabs_Atl, slabs_Ind_Pac)

```

```{r meridional_sections_isoneutral_slabs, fig.asp=0.6}

GLODAP_cruise <- GLODAP %>% 
  filter(cruise %in% cruises_meridional)

lat_section <- 
GLODAP_cruise %>%
  ggplot(aes(lat, depth)) +
  scale_y_reverse() +
  theme(legend.position = "bottom")

lat_section +
  geom_point(aes(col = gamma)) +
  scale_color_viridis_c()

lat_section +
  geom_point(aes(col = gamma_slab)) +
  scale_color_viridis_d()


rm(lat_section, GLODAP_cruise, cruises_meridional)

```


## Predictor correlation

The correlation between:  

- pairs of seven potential predictor variables and
- C* and seven potential predictor variables

were investigated based on:  

- property-property plots and
- calculated correlation coeffcients.

### Correlation plots

For an overview, a random subset of data from all eras was plotted separately 
for both basins, with color indicating neutral density slabs (high density = dark-purple color).

```{r predictor_correlation_Atlantic, fig.asp=1}

GLODAP %>% 
  filter(basin == "Atlantic") %>% 
  sample_frac(0.05) %>% 
  ggpairs(columns = c("Cstar",
                      "sal",
                      "tem",
                      "aou",
                      "oxygen",
                      "silicate",
                      "phosphate",
                      "phosphate_star"),
          upper = "blank",
          ggplot2::aes(col = gamma_slab, fill = gamma_slab, alpha = 0.01)) +
      scale_fill_viridis_d(direction = -1) +
      scale_color_viridis_d(direction = -1) +
      labs(title = paste("Basin: Atlantic | era: all | subsample size: 5 % of",
                         nrow(GLODAP %>% filter(basin == "Atlantic"))))

```

```{r predictor_correlation_Indo_Pacific, fig.asp=1}

GLODAP %>% 
  filter(basin == "Indo-Pacific") %>% 
  sample_frac(0.05) %>% 
  ggpairs(columns = c("Cstar",
                      "sal",
                      "tem",
                      "aou",
                      "oxygen",
                      "silicate",
                      "phosphate",
                      "phosphate_star"),
          upper = "blank",
          ggplot2::aes(col = gamma_slab, fill = gamma_slab, alpha = 0.01)) +
      scale_fill_viridis_d(direction = -1) +
      scale_color_viridis_d(direction = -1) +
      labs(title = paste("Basin: Indo-Pacific | era: all | subsample size: 5 % of",
                         nrow(GLODAP %>% filter(basin == "Indo-Pacific") )))


```

Individual correlation plots for each basin, era and neutral density (gamma) slab are available [here](https://github.com/jens-daniel-mueller/Cant_eMLR/tree/master/output/figure/eMLR/predictor_correlation){target="_blank"}.

```{r predictor_correlation_per_basin_era_slab, eval=FALSE}


for (i_basin in unique(GLODAP$basin)) {
  for (i_era in unique(GLODAP$era)) {

# i_basin <- unique(GLODAP$basin)[1]
# i_era   <- unique(GLODAP$era)[1]

print(i_basin)
print(i_era)

GLODAP_basin_era <- GLODAP %>% 
  filter(basin == i_basin,
         era == i_era)

for (i_gamma_slab in unique(GLODAP_basin_era$gamma_slab)) {
  
  # i_gamma_slab <- unique(GLODAP_basin_era$gamma_slab)[5]
  print(i_gamma_slab)
  
  GLODAP_highlight <- GLODAP_basin_era %>% 
  mutate(gamma_highlight = if_else(gamma_slab == i_gamma_slab,
                                   "in", "out")) %>%
    arrange(desc(gamma_highlight))
  
p <- GLODAP_highlight %>% 
  ggpairs(columns = c("Cstar",
                      "sal",
                      "tem",
                      "aou",
                      "oxygen",
                      "silicate",
                      "phosphate",
                      "phosphate_star"),
          ggplot2::aes(col = gamma_highlight, fill = gamma_highlight, alpha = 0.01)) +
      scale_fill_manual( values = c("red", "grey")) +
      scale_color_manual(values = c("red", "grey")) +
      labs(title = paste(i_basin,
                         "|", i_era,
                         "| Gamma slab", i_gamma_slab,
                         "| # obs total", nrow(GLODAP_basin_era),
                         "| # obs slab", nrow(GLODAP_highlight %>% 
                                             filter(gamma_highlight == "in"))))
  

png(here::here("output/figure/eMLR/predictor_correlation",
               paste("predictor_correlation", i_basin, i_era, i_gamma_slab, ".png", sep = "_")),
    width = 12, height = 12, units = "in", res = 300)

print(p)

dev.off()
  
    }
  }
}


```

### Correlation assesment

#### Calculation of correlation coeffcients

Correlation coefficients were calculated indivdually within each slabs, era and basin.

```{r calculate_correlation_coefficients, eval=FALSE}

for (i_basin in unique(GLODAP$basin)) {
  for (i_era in unique(GLODAP$era)) {

# i_basin <- unique(GLODAP$basin)[1]
# i_era   <- unique(GLODAP$era)[1]
print(i_basin)
print(i_era)

GLODAP_basin_era <- GLODAP %>% 
  filter(basin == i_basin,
         era == i_era) %>% 
  select(basin,
         era,
         gamma_slab,
         Cstar,
         sal,
         tem,
         aou,
         oxygen,
         silicate,
         phosphate,
         phosphate_star)

for (i_gamma_slab in unique(GLODAP_basin_era$gamma_slab)) {
  
  # i_gamma_slab <- unique(GLODAP_basin_era$gamma_slab)[5]
  print(i_gamma_slab)
  
  GLODAP_basin_era_slab <- GLODAP_basin_era %>%
    filter(gamma_slab == i_gamma_slab)

  cor_Cstar_predictor_temp <- GLODAP_basin_era_slab %>% 
    select(-c(basin, era, gamma_slab)) %>% 
    correlate() %>% 
    focus(Cstar) %>% 
    mutate(basin = i_basin,
       era = i_era,
       gamma_slab = i_gamma_slab)
  
  if (exists("cor_Cstar_predictor")) {
        cor_Cstar_predictor <- bind_rows(cor_Cstar_predictor, cor_Cstar_predictor_temp)
      }
      
    if (!exists("cor_Cstar_predictor")) {
        cor_Cstar_predictor <- cor_Cstar_predictor_temp
    }
  
  
  cor_predictors_temp <- GLODAP_basin_era_slab %>% 
    select(-c(basin, era, gamma_slab)) %>% 
    correlate() %>% 
    shave %>% 
    stretch() %>% 
    filter(!is.na(r),
           x != "Cstar",
           y != "Cstar") %>% 
    mutate(pair = paste(x, y, sep = " + ")) %>% 
    select(-c(x, y)) %>% 
    mutate(basin = i_basin,
       era = i_era,
       gamma_slab = i_gamma_slab)
  
    if (exists("cor_predictors")) {
        cor_predictors <- bind_rows(cor_predictors, cor_predictors_temp)
      }
      
    if (!exists("cor_predictors")) {
        cor_predictors <- cor_predictors_temp
    }
  
  
  
    }
  }
}


cor_predictors %>%
  write_csv(here::here("data/eMLR",
                       "cor_predictors.csv"))

cor_Cstar_predictor %>%
  write_csv(here::here("data/eMLR",
                       "cor_Cstar_predictor.csv"))

rm(cor_predictors_temp, cor_Cstar_predictor_temp,
   i_gamma_slab, i_era, i_basin,
   GLODAP_basin_era, GLODAP_basin_era_slab)

```

#### Predictor pairs

Below, the range of correlations coefficients for each predictor pair is plotted per basin (facet) and density slab (color). Note that the range indicates the min and max values of in total 3 calculated coefficients (one per era).

```{r correlation_predictor_pairs, fig.asp=1.8}

cor_predictors <-
  read_csv(here::here("data/eMLR",
                       "cor_predictors.csv"))

cor_predictors_stats <- cor_predictors %>% 
  group_by(pair, basin, gamma_slab) %>% 
  summarise(mean_r = mean(r),
            min_r = min(r),
            max_r = max(r)) %>% 
  ungroup()

cor_predictors_stats %>% 
  mutate(pair = reorder(pair, mean_r)) %>%
  ggplot() +
  geom_vline(xintercept = c(-0.9, 0.9), col = "red") +
  geom_vline(xintercept = 0) +
  geom_linerange(
    aes(y = pair, xmin = min_r, xmax = max_r, col = gamma_slab),
    position = position_dodge(width = 0.6)) +
  facet_wrap(~basin) +
  scale_color_viridis_d(direction = -1) +
  labs(x = "correlation coefficient", y = "") +
  theme(legend.position = "top")

kable(cor_predictors_stats) %>%
  add_header_above() %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")

rm(cor_predictors, cor_predictors_stats)

```

#### C* vs individual predictors


Below, the range of correlations coefficients for C* with each predictor is plotted per basin (facet) and density slab (color). Note that the range indicates the min and max values of in total 3 calculated coefficients (one per era).

```{r correlation_predictors, fig.asp=1.5}

cor_Cstar_predictor <-
  read_csv(here::here("data/eMLR",
                       "cor_Cstar_predictor.csv")) %>% 
  rename(predictor = rowname)

cor_Cstar_predictor_stats <- cor_Cstar_predictor %>% 
  group_by(predictor, basin, gamma_slab) %>% 
  summarise(mean_r = mean(Cstar),
            min_r = min(Cstar),
            max_r = max(Cstar)) %>% 
  ungroup()

cor_Cstar_predictor_stats %>% 
  mutate(predictor = reorder(predictor, mean_r)) %>%
  ggplot() +
  geom_vline(xintercept = c(-0.9, 0.9), col = "red") +
  geom_vline(xintercept = 0) +
  geom_linerange(
    aes(y = predictor, xmin = min_r, xmax = max_r, col = gamma_slab),
    position = position_dodge(width = 0.6)) +
  facet_wrap(~basin) +
  scale_color_viridis_d(direction = -1) +
  labs(x = "correlation coefficient", y = "C* correlation with...") +
  theme(legend.position = "top")

kable(cor_Cstar_predictor_stats) %>%
  add_header_above() %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")

rm(cor_Cstar_predictor, cor_Cstar_predictor_stats)

```


## Model fitting

```{r write_csv_GLODAP_used_for_fitting, eval = FALSE}

GLODAP %>% write_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
                                "GLODAP_MLR_fitting_ready.csv"))

```

### Predictor selection

Individual linear regression models were fitted for C* as a function of each predictor combination. Fitting was performed separately within each basin, era, and slab. The root mean squared error (RMSE) was calculated for each fitted model.

```{r eMLR_fitting_predictor_selection, eval=FALSE}

for (i_basin in unique(GLODAP$basin)) {
  for (i_era in unique(GLODAP$era)) {
    
    # i_basin <- unique(GLODAP$basin)[1]
    # i_era   <- unique(GLODAP$era)[1]
    
    print(i_basin) 
    print(i_era  )
    
    GLODAP_basin_era <- GLODAP %>%
      filter(basin == i_basin, era == i_era)

    for (i_gamma_slab in unique(GLODAP_basin_era$gamma_slab)) {

      # i_gamma_slab <- unique(GLODAP_basin_era$gamma_slab)[1]
      print(i_gamma_slab)
      
      GLODAP_basin_era_slab <- GLODAP_basin_era %>% 
        filter(gamma_slab == i_gamma_slab)
      
      lm_full <- lm(Cstar ~ 
                sal  + 
                tem  + 
                aou  + 
                oxygen  + 
                silicate  + 
                phosphate  + 
                phosphate_star, 
              data = GLODAP_basin_era_slab)
      
      lm_all <- ols_step_all_possible(lm_full)
      
      temp <- as_tibble(lm_all$result)
      
      temp <- temp %>% 
        mutate(basin = i_basin,
               era = i_era,
               gamma_slab = i_gamma_slab)
      
      if (exists("all_lm_stats")) {
        all_lm_stats <- bind_rows(all_lm_stats, temp)
      }
      
      if (!exists("all_lm_stats")) {
        all_lm_stats <- temp
      }
      
      rm(lm_full, lm_all, temp)
      
    }
    
  }
  
}

all_lm_stats %>%
  write_csv(here::here("data/eMLR",
                       "all_lm_stats.csv"))

rm(i_gamma_slab, i_era, i_basin,
   GLODAP_basin_era, GLODAP_basin_era_slab,
   all_lm_stats)

```

```{r set_criteria_predictor_number}

n_predictors_max <- 5
n_predictors_min <- 2

n_predictors_total <- 10

```


RMSE was plotted against the number of predictors (limited to `r n_predictors_min` - `r n_predictors_max`).

```{r eMLR_predictor_model_quality, fig.asp=2}

all_lm_stats <- read_csv(here::here("data/eMLR",
                                    "all_lm_stats.csv"))

# nrow(all_lm_stats)
# length(unique(all_lm_stats$rmse))
# length(unique(all_lm_stats$adjr))
# length(unique(all_lm_stats$rsquare))
# length(unique(all_lm_stats$cp))
# length(unique(all_lm_stats$aic))
# length(unique(all_lm_stats$mindex))

all_lm_stats <- all_lm_stats %>% 
  filter(n >= n_predictors_min,
         n <= n_predictors_max)

all_lm_stats %>% 
  ggplot(aes(n, rmse, col = basin)) +
  geom_hline(yintercept = 10) + 
  geom_point(shape = 21) +
  facet_grid(gamma_slab~era) +
  scale_color_brewer(palette = "Set1")

```

Within each basin and slab, the `r n_predictors_total` linear regression models with lowest summed RMSE across all eras were selected.

```{r predictor_selection}

all_lm_stats <- all_lm_stats %>% 
  select(basin, era, gamma_slab, predictors, rmse)

all_lm_stats_wide <- all_lm_stats %>% 
  pivot_wider(names_from = era, values_from = rmse, names_prefix = "rmse_")

all_lm_stats_wide <- all_lm_stats_wide %>% 
  mutate(rmse_sum = rmse_JGOFS_WOCE + rmse_GO_SHIP + rmse_new_era)

lm_best <- all_lm_stats_wide %>% 
  group_by(basin, gamma_slab) %>% 
  slice_min(order_by = rmse_sum,
            with_ties = FALSE,
            n = n_predictors_total) %>% 
  ungroup()

kable(lm_best) %>%
  add_header_above() %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")

# lm_best_n <-lm_best %>% 
#   group_by(basin, gamma_slab) %>% 
#   summarise(n()) %>% 
#   ungroup()

rm(n_predictors_max, n_predictors_min, 
   all_lm_stats, all_lm_stats_wide)

```

```{r test_rmse_output, eval=FALSE}

lm_1 <- GLODAP %>% 
  filter(basin == "Atlantic",
         gamma_slab == "(-Inf,26]",
         era == "new_era") %>% 
  lm(Cstar ~ salinity + temperature + aou + oxygen + phosphate_star, data = .)

lm_2 <- GLODAP %>% 
  filter(basin == "Atlantic",
         gamma_slab == "(-Inf,26]",
         era == "new_era") %>% 
  lm(Cstar ~ salinity + temperature + aou + oxygen + phosphate, data = .)

lm_1
lm_2

sqrt(mean(lm_1$residuals^2))
sqrt(mean(lm_2$residuals^2))

```



### Fitting best models

After selecting `r n_predictors_total` linear regression models with lowest summed RMSE across all eras, models are fitted again and model coefficients are saved to file.

```{r fit_best_models, eval=FALSE}

lm_best <- lm_best %>% 
  mutate(lm_coeff = str_replace_all(predictors, " ", " + "),
         lm_coeff = paste("Cstar ~", lm_coeff))

for (i_basin in unique(GLODAP$basin)) {
  for (i_era in unique(GLODAP$era)) {
    
    # i_basin <- unique(GLODAP$basin)[1]
    # i_era   <- unique(GLODAP$era)[1]
    
    print(i_basin) 
    print(i_era  )
    
    GLODAP_basin_era <- GLODAP %>%
      filter(basin == i_basin, era == i_era)

    lm_best_basin <- lm_best %>%
      filter(basin == i_basin)

    for (i_gamma_slab in unique(GLODAP_basin_era$gamma_slab)) {

      # i_gamma_slab <- unique(GLODAP_basin_era$gamma_slab)[1]
      print(i_gamma_slab)
      
      GLODAP_basin_era_slab <- GLODAP_basin_era %>% 
        filter(gamma_slab == i_gamma_slab)
      
      lm_best_basin_slab <- lm_best_basin %>% 
        filter(gamma_slab == i_gamma_slab)
      
      for (i_predictors in unique(lm_best_basin_slab$predictors)) {
        
        # i_predictors <- unique(lm_best_basin_slab$predictors)[1]
        
        lm_best_single <- lm_best_basin_slab %>%
          filter(predictors == i_predictors) %>%
          select(lm_coeff) %>%
          pull()
        
        i_rmse_sum <- lm_best_basin_slab %>%
          filter(predictors == i_predictors) %>%
          select(rmse_sum) %>%
          pull()
        
        lm_formula <- as.formula(lm_best_single)
        
        model_single <- lm(lm_formula, 
              data = GLODAP_basin_era_slab)
        
        coefficients <- tidy(model_single)
        coefficients <- coefficients %>% 
          mutate(basin = i_basin,
                 era = i_era,
                 gamma_slab = i_gamma_slab,
                 model = lm_best_single,
                 rmse = i_rmse_sum)
        
        print(lm_best_single)
      
      if (exists("all_lm")) {
        all_lm <- bind_rows(all_lm, coefficients)
      }
      
      if (!exists("all_lm")) {
        all_lm <- coefficients
      }
      

      }
      
 
    }
    
  }
  
}


rm(lm_formula, model_single, coefficients, i_rmse_sum,
   GLODAP_basin_era, GLODAP_basin_era_slab,
   lm_best, lm_best_basin, lm_best_basin_slab, lm_best_single,
   i_basin, i_era, i_gamma_slab, i_predictors)

all_lm %>%
  write_csv(here::here("data/eMLR",
                       "all_lm.csv"))

```


# Open tasks

- combine correlation, rmse and model calculation into one routine, ideally using the purrr map approach
- select exactly best 10 models, even if same rmse sum appears more than once (currently, selection is set two ten, even if doublicated rmse occur)

# Open questions
