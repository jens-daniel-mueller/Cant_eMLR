---
title: "Data base"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```

```{r library, message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(patchwork)
library(broom)
library(GGally)

```


```{r ggplot_theme, include = FALSE}
theme_set(theme_bw())
```

# Required data

Required are: 

- clean version of GLODAPGLODAPv2.2020
- C_ant from GLODAPv2_2016b_MappedClimatologies
- annual mean atmospheric pCO~2~ 

```{r load_required_data_sets}

GLODAP <- read_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
                              "GLODAPv2.2020_clean.csv"))

Cant_clim <- read_csv(here::here("data/GLODAPv2_2016b_MappedClimatologies/_summarized_files",
                                 "Cant.csv"))

co2_atm <- read_csv(here::here("data/pCO2_atmosphere/_summarized_data_files",
                               "co2_atm.csv"))

```

# C*

## Stoichiometric ratios

```{r set_stoichiometric_ratios}

rCP <- 117
rNP <- 16

```

The stoichiometric nutrient ratios for the production and mineralization of organic matter were set to:

- C/P: `r rCP`
- N/P: `r rNP`

## Calculation

```{r calculate_Cstar}

GLODAP <- GLODAP %>% 
  mutate(rCP_phosphate = - rCP * phosphate,
         talk_05 = - 0.5 * talk,
         rNP_phosphate_05 = - 0.5 * rNP * phosphate,
         Cstar = tco2  + rCP_phosphate  + talk_05  + rNP_phosphate_05)

```


# Reference year adjustment

The scaling factor for the reference year adjustment is an apriori estiamte of Cant at a given location and depth. Here, Cant from the GLODAP mapped Climatology was used.  

Note that eq. 6 in Clement and Gruber (2018) misses pCO2 pre-industrial in the denominator. Here we use the equation published in Gruber et al. (2019).

## Merge GLODAP data set with...

### ... Cant

```{r merge_Cstar_Cant}

Cant_clim <- Cant_clim %>% 
  drop_na()

# GLODAP_Cant_full <- full_join(GLODAP, Cant_clim)
# 
# GLODAP_Cant_full %>% write_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
#                                           "GLODAP_Cant_full.csv"))

GLODAP_Cant_full <- read_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
                                          "GLODAP_Cant_full.csv"))

```

The mapped Cant product was merged with GLODAP observation by:

- using an identical 1x1° horizontal grid
- linear interpolation of Cant from standard to sampling depth

```{r interpolate_Cant_to_observations}

GLODAP_Cant_observations_available <- GLODAP_Cant_full %>% 
  group_by(lat, lon) %>% 
  mutate(n_GLODAP = sum(!is.na(Cstar))) %>% 
  ungroup() %>% 
  filter(n_GLODAP > 0) %>% 
  select(-n_GLODAP)

rm(GLODAP_Cant_full)

GLODAP_Cant_observations_available <- GLODAP_Cant_observations_available %>% 
  group_by(lat, lon) %>% 
  arrange(depth) %>% 
  mutate(Cant_int = approxfun(depth, Cant, rule = 2)(depth)) %>% 
  ungroup()

ggplot() +
    geom_path(data = GLODAP_Cant_observations_available %>% 
              filter(lat == 48.5, lon == 165.5, !is.na(Cant)) %>% 
              arrange(depth),
            aes(Cant, depth, col="mapped")) +
  geom_point(data = GLODAP_Cant_observations_available %>% 
              filter(lat == 48.5, lon == 165.5, !is.na(Cant)) %>% 
              arrange(depth),
            aes(Cant, depth, col="mapped")) +
  geom_point(data = GLODAP_Cant_observations_available %>% 
              filter(lat == 48.5, lon == 165.5, date == ymd("2018-06-27")),
            aes(Cant_int, depth, col="interpolated")) +
  scale_y_reverse() +
  scale_color_brewer(palette = "Dark2", name="") +
  labs(title = "Cant interpolation to sampling depth - example profile")

GLODAP <- GLODAP_Cant_observations_available %>% 
  filter(!is.na(Cstar)) %>% 
  mutate(Cant = Cant_int) %>% 
  select(-Cant_int)

rm(GLODAP_Cant_observations_available, Cant_clim)

```

### ... Atmospheric pCO2

```{r merge_Cstar_pCO2}

GLODAP <- left_join(GLODAP, co2_atm)

```


## Calculate adjustment

```{r adjust_reference_year}

GLODAP <- GLODAP %>% 
  group_by(era) %>% 
  mutate(tref = median(year)) %>% 
  ungroup()

tref <- GLODAP %>% 
  group_by(era) %>% 
  summarise(year = median(year)) %>% 
  ungroup()

co2_atm_tref <- right_join(co2_atm, tref) %>% 
  select(-year) %>% 
  rename(pCO2_tref = pCO2)

GLODAP <- full_join(GLODAP, co2_atm_tref)

rm(co2_atm, co2_atm_tref, tref)

GLODAP <- GLODAP %>% 
  mutate(Cstar_tref_delta = 
           ( (pCO2 - pCO2_tref) / (pCO2_tref - 280) ) * Cant,
         Cstar_tref = Cstar - Cstar_tref_delta)

```

## Control plots

```{r Cstar_reference_year_adjustment_histogram}

GLODAP %>% 
  ggplot(aes(Cstar_tref_delta)) +
  geom_histogram()

```


```{r Cstar_reference_year_adjustment_vs_time_difference_Cant}

GLODAP %>% 
  sample_n(10000) %>% 
  ggplot(aes(year - tref, Cstar_tref_delta, col=Cant)) +
  geom_point() +
  scale_color_viridis_c() +
  labs(title = "random subsample 1e4")

```


# Selected section plots

Selected sections are plotted to demonstrate the magnitude of various parameters and corrections relevant to C*.

```{r select_cruises}

cruises_meridional <- c("1041")

# cruises_meridional <- c("1041","1042", "260",
#                         "2011", "393", "1031", "394", "395",
#                         "1088", "983")

# cruises_zonal <- c()

GLODAP_cruise <- GLODAP %>% 
  filter(cruise %in% cruises_meridional)

```

```{r interpolate_raster_section, eval=FALSE}

bbox <- c(
  "xmin" = min(GLODAP_cruise$lat),
  "ymin" = min(GLODAP_cruise$depth),
  "xmax" = max(GLODAP_cruise$lat),
  "ymax" = max(GLODAP_cruise$depth)
)

grd_template <- expand.grid(
  lat = seq(from = bbox["xmin"], to = bbox["xmax"], by = 1),
  depth = seq(from = bbox["ymin"], to = bbox["ymax"], by = 50) # 20 m resolution
)

crs_raster_format <- " +proj=utm  +zone=33  +ellps=GRS80  +towgs84=0,0,0,0,0,0,0  +units=m  +no_defs"

grd_template_raster <- grd_template %>% 
  dplyr::mutate(Z = 0) %>% 
  raster::rasterFromXYZ( 
    crs = crs_raster_format)


# Generalized Additive Model
fit_GAM <- mgcv::gam( # using {mgcv}
  gamma ~ s(lat, depth),      # here come our X/Y/Z data - straightforward enough
  data = GLODAP_cruise      # specify in which object the data is stored
)

# Generalized Additive Model
interp_GAM <- grd_template %>% 
  mutate(Z = predict(fit_GAM, .)) %>% 
  raster::rasterFromXYZ(crs = crs_raster_format)

df <- raster::rasterToPoints(interp_GAM) %>% as_tibble()
colnames(df) <- c("X", "Y", "Z")
  
ggplot(df, aes(x = X, y = Y, fill = Z, z = Z))  +
  geom_raster()  +
  geom_contour(col="white")  +
  ggtitle(label = "interp GAM")  +
  scale_fill_viridis_c()  +
  scale_y_reverse() +
  coord_cartesian(expand = 0)

```




```{r meridional_sections, fig.asp=0.6}

mapWorld <- borders("world", colour="gray60", fill="gray60")

GLODAP_cruise %>%
  arrange(date) %>% 
  ggplot(aes(lon, lat)) +
  mapWorld +
  geom_path() +
  geom_point(aes(col=date)) +
  coord_quickmap(expand = 0) +
  scale_color_viridis_c(trans = "date") +
  labs(title = paste("Cruise year:", mean(GLODAP_cruise$year))) +
  theme(legend.position = "bottom")

lat_section <- 
GLODAP_cruise %>%
  ggplot(aes(lat, depth)) +
  scale_y_reverse() +
  scale_color_viridis_c() +
  theme(legend.position = "bottom")

lat_section +
  geom_point(aes(col=tco2))

lat_section +
  geom_point(aes(col=talk))

lat_section +
  geom_point(aes(col=phosphate))

lat_section +
  geom_point(aes(col=rCP_phosphate))

lat_section +
  geom_point(aes(col=talk_05))

lat_section +
  geom_point(aes(col=rNP_phosphate_05))

lat_section +
  geom_point(aes(col=Cstar))

lat_section +
  geom_point(aes(col=Cant))

lat_section +
  geom_point(aes(col=-Cstar_tref_delta))


rm(mapWorld, lat_section, GLODAP_cruise)

```




# MLR

## Isoneutral slabs

```{r define_isoneutral_slabs}

slabs_Atl <- c(
-Inf,
26.00,
26.50,
26.75,
27.00,
27.25,
27.50,
27.75,
27.85,
27.95,
28.05,
28.10,
28.15,
28.20,
Inf)

slabs_Ind_Pac <- c(
-Inf,
26.00,
26.50,
26.75,
27.00,
27.25,
27.50,
27.75,
27.85,
27.95,
28.05,
28.10,
Inf)


```

The following boundaries for isoneutral slabs were defined:

- Atlantic: `r slabs_Atl`
- Indo-Pacific: `r slabs_Ind_Pac`

```{r cut_isoneutral_slabs}

GLODAP_Atl <- GLODAP %>% 
  filter(basin == "Atlantic") %>% 
  mutate(gamma_slab = cut(gamma, slabs_Atl))

GLODAP_Ind_Pac <- GLODAP %>% 
  filter(basin == "Indo-Pacific") %>% 
  mutate(gamma_slab = cut(gamma, slabs_Ind_Pac))

GLODAP <- bind_rows(GLODAP_Atl, GLODAP_Ind_Pac)
rm(GLODAP_Atl, GLODAP_Ind_Pac)

```

```{r isoneutral_slabs_section, fig.asp=0.6}

GLODAP_cruise <- GLODAP %>% 
  filter(cruise %in% cruises_meridional)

lat_section <- 
GLODAP_cruise %>%
  ggplot(aes(lat, depth)) +
  scale_y_reverse() +
  theme(legend.position = "bottom")

lat_section +
  geom_point(aes(col=gamma)) +
  scale_color_viridis_c()

lat_section +
  geom_point(aes(col=gamma_slab)) +
  scale_color_viridis_d()


```

## PO~4~* calculation 

```{r calculate_phosphate_star}

GLODAP <- GLODAP %>% 
  mutate(phosphate_star = phosphate - 16*nitrate  + 29)

```

## Predictor correlation

```{r predictor_correlation_all, fig.asp=1}

GLODAP %>% 
  sample_frac(0.1) %>% 
  ggpairs(columns = c("Cstar",
                      "salinity",
                      "temperature",
                      "aou",
                      "oxygen",
                      "silicate",
                      "phosphate",
                      "phosphate_star"),
          ggplot2::aes(col = gamma_slab, fill = gamma_slab, alpha = 0.01)) +
      scale_fill_viridis_d() +
      scale_color_viridis_d() +
      labs(title = paste("Basin: all | era: all | subsample size: 10 %"))


```

Individual correlation plots for each basin and era are available upon request.

```{r predictor_correlation_basin_era, eval=FALSE}


for (i_basin in unique(GLODAP$basin)) {
  for (i_era in unique(GLODAP$era)) {

# i_basin <- unique(GLODAP$basin)[1]
# i_era   <- unique(GLODAP$era)[1]
print(i_basin)
print(i_era)

p <- GLODAP %>% 
  filter(basin == i_basin, era == i_era) %>% 
  sample_frac(0.1) %>% 
  ggpairs(columns = c("salinity","temperature", "aou", "oxygen", "silicate", "phosphate", "phosphate_star"),
          ggplot2::aes(col = gamma_slab, fill = gamma_slab, alpha = 0.01)) +
      scale_fill_viridis_d() +
      scale_color_viridis_d() +
      labs(title = paste("Basin:", i_basin, "| era:", i_era, "| subsample size: 10%")) +
      theme(text = element_text(size=20))
  
png(here::here("output/figure/eMLR/predictor_correlation",
               paste("predictor_correlation", i_basin, i_era, ".png", sep = "_")),
    width = 20, height = 20, units = "in", res = 300)

print(p)

dev.off()

  }
}

```

## Model fitting

```{r write_csv_GLODAP_used_for_fitting}

GLODAP %>% write_csv(here::here("data/GLODAPv2_2020/_summarized_data_files",
                                "GLODAP_MLR_fitting_ready.csv"))

```


```{r eMLR_fitting}

MLRs <- GLODAP %>%
  nest(data = -c(basin, era, gamma_slab)) %>% 
  mutate(
    fit = map(data, ~ lm(Cstar ~ salinity  + temperature  + aou  + oxygen  + silicate  + phosphate  + phosphate_star,
                         data = .x)),
    tidied = map(fit, tidy),
    glanced = map(fit, glance),
    augmented = map(fit, augment)
  )

MLRs_tidied <- MLRs %>% 
  unnest(tidied)

MLRs_tidied

MLRs_tidied <- MLRs_tidied %>% 
  select(era, basin, gamma_slab, term, estimate, p.value)

MLRs_tidied_wide <- MLRs_tidied %>% 
  select(-p.value) %>% 
  pivot_wider(names_from = era, values_from = estimate, names_prefix = "coeff_")

MLRs_tidied_wide <- MLRs_tidied_wide %>% 
  mutate(delta_coeff_J_G = coeff_GO_SHIP - coeff_JGOFS_WOCE,
         delta_coeff_G_n = coeff_new_era - coeff_GO_SHIP,
         delta_coeff_n_G = coeff_new_era - coeff_JGOFS_WOCE)

MLRs_tidied %>% 
  ggplot(aes(p.value, term, col=gamma_slab)) +
  geom_point() +
  facet_grid(basin~era)

MLRs_tidied %>% 
  filter(p.value < 0.05) %>% 
  ggplot(aes(p.value, term, col=gamma_slab)) +
  geom_point() +
  facet_grid(basin~era)

MLRs_tidied %>% 
  ggplot(aes(p.value, term)) +
  geom_boxplot() +
  facet_grid(basin~era)

MLRs %>% 
  unnest(glanced)

MLRs %>% 
  unnest(augmented)

```

```{r predictor_combinations_test, eval=FALSE}

mtcars <- mtcars %>% 
  select(mpg, disp, hp) %>% 
  as_tibble()

model <- "disp  + hp"

lm(data = mtcars, mpg ~ model)


```


```{r predictor_variables, eval=FALSE}

temperature
salinity
phosphate
silicate
phosphate_star = phosphate  + (oxygen / 170) - 1.95
oxygen
aou


```

```{r estimate_MLR_models, eval=FALSE}

basins <- c("Atlantic", "Indo_Pacific")
slabs <- c("")

for (i_basin in basins) {
  for (i_slab in slabs) {
    
    
  }
  
}

```
